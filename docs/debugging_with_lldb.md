# LLDB를 이용한 디버깅 가이드

이 문서는 `lldb` 디버거를 사용하여 MXRC 프로젝트의 크래시(특히, 세그멘테이션 폴트)를 분석하고 원인을 찾는 방법을 안내합니다.

## 개요

세그멘테이션 폴트와 같은 메모리 접근 오류는 프로그램의 특정 지점에서 잘못된 메모리 주소에 접근하려고 할 때 발생합니다. `lldb`는 이러한 오류가 발생했을 때 프로그램을 중단시키고, 당시의 메모리 상태, 레지스터 값, 함수 호출 스택 등을 분석할 수 있는 강력한 도구입니다.

## 디버깅 절차

### 1단계: 런타임 환경 검증

크래시 분석에 앞서, 라이브러리 로드 실패와 같은 기본적인 환경 문제를 먼저 확인하는 것이 좋습니다.

*   **목적**: 동적 라이브러리(예: TBB) 경로가 올바르게 설정되었는지 확인합니다. 경로 누락은 세그멘테이션 폴트의 흔한 원인 중 하나입니다.
*   **명령 (macOS)**:
    ```bash
    echo $DYLD_LIBRARY_PATH
    ```
*   **확인**: 출력된 경로에 필요한 라이브러리(예: `/opt/homebrew/opt/tbb/lib`)가 포함되어 있는지 확인합니다.

### 2단계: LLDB로 테스트 실행 파일 실행

디버거를 붙여 테스트를 실행하여 크래시가 발생하는 정확한 지점을 포착합니다.

*   **목적**: 세그멘테이션 폴트가 발생한 시점에 프로세스를 중단시키고 디버깅 세션을 시작합니다.
*   **명령**:
    1.  `lldb`에 실행 파일을 로드합니다.
        ```bash
        lldb ./build/run_tests
        ```
    2.  `lldb` 프롬프트에서 `run` 명령어로 프로그램을 실행합니다.
        ```lldb
        (lldb) run
        ```

*   **결과**: 크래시가 발생하면, `lldb`는 해당 지점에서 실행을 멈추고 스레드 상태, 중단 이유, 오류가 발생한 코드 라인을 보여줍니다.

    ```text
    Process 164 stopped
    * thread #2, stop reason = EXC_BAD_ACCESS (code=1, address=0x10)
        frame #0: 0x0000000100208004 run_tests`MapNotifier::notify(SharedData const&) + 128
    run_tests`MapNotifier::notify:
    ->  0x100208004 <+128>: ldr    x8, [x8, #0x10]
    ```

### 3단계: 스택 트레이스 및 레지스터 분석

크래시가 발생한 지점의 컨텍스트를 파악하여 원인을 분석합니다.

*   **목적**: 오류 발생 지점까지의 함수 호출 경로를 추적하고, 레지스터 값과 어셈블리 코드를 통해 오류의 구체적인 성격을 파악합니다.
*   **주요 명령어**:
    *   `bt` (backtrace): 현재 스레드의 함수 호출 스택을 출력합니다.
    *   `register read`: 모든 레지스터의 현재 값을 출력합니다.
    *   `frame variable`: 현재 스택 프레임의 변수들을 보여줍니다.

#### 분석 예시: NULL 포인터 역참조

위의 크래시 예시를 분석해 보겠습니다.

1.  **오류 메시지 확인**:
    *   `EXC_BAD_ACCESS (code=1, address=0x10)`: `0x10` 주소에 잘못된 접근을 시도했다는 의미입니다. 이 주소는 일반적으로 NULL 포인터(`0x0`)에서 작은 오프셋만큼 떨어진 위치를 가리킬 때 나타납니다.

2.  **어셈블리 코드 분석**:
    *   `ldr x8, [x8, #0x10]`: `x8` 레지스터가 가리키는 주소에 `0x10`(16바이트)를 더한 위치에서 값을 읽어와 다시 `x8`에 저장하라는 명령입니다.
    *   오류가 이 지점에서 발생했다는 것은, `x8` 레지스터의 값이 유효한 주소가 아니라는 것을 의미합니다.

3.  **결론 도출**:
    *   `lldb`로 `x8` 레지스터의 값을 확인해보면 `0x0` (NULL) 이었을 가능성이 매우 높습니다.
    *   결론적으로, 어떤 객체의 포인터(레지스터 `x8`에 담겨 있던)가 NULL이었고, 해당 객체의 16바이트 오프셋에 위치한 멤버 변수에 접근하려다 크래시가 발생한 것입니다. 이는 **NULL 포인터 역참조(Dereference)** 오류입니다.

이 정보를 바탕으로, 개발자는 `MapNotifier::notify` 함수 내에서 해당 포인터가 NULL이 되는 로직을 추적하여 문제를 해결할 수 있습니다.
