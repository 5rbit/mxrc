# RT/Non-RT 프로세스 분리 아키텍처 분석

## 1. 개요 (Overview)

본 문서는 MXRC 시스템의 핵심 아키텍처인 **듀얼 프로세스(Dual-Process)** 설계를 분석하고 평가합니다. 시스템은 다음과 같은 두 개의 독립적인 프로세스로 구성됩니다.

- **실시간 (Real-Time, RT) 프로세스**: `mxrc-rt`
- **비실시간 (Non-Real-Time, Non-RT) 프로세스**: `mxrc-nonrt`

이 아키텍처의 핵심 목표는 **RT 작업의 예측 가능성(predictability)과 결정성(determinism)을 보장**하는 것입니다. 복잡하고 비결정적인 Non-RT 작업을 별도의 프로세스로 격리함으로써, RT 프로세스는 시간 제약이 엄격한 제어 로직을 안정적으로 수행할 수 있습니다.

## 2. 프로세스 상세 (Process Details)

### 2.1. RT 프로세스 (`mxrc-rt`)

- **진입점**: `src/rt_main.cpp`
- **핵심 컴포넌트**: `RTExecutive`
- **주요 책임**:
    - 주기적이고 결정론적인 작업 실행 (예: 센서 데이터 읽기, 액추에이터 제어).
    - `RTExecutive`가 메인 루프를 돌며 등록된 `IAction`들을 정해진 주기에 맞춰 실행.
    - Non-RT 프로세스의 생존 여부를 하트비트(heartbeat)로 감시.
    - 제어 상태와 같은 RT 데이터를 공유 메모리에 기록.
- **실행 환경**:
    - `systemd` 서비스(`mxrc-rt.service`)를 통해 실행되며, **CPU 고정(CPUAffinity)** 및 **실시간 스케줄링 우선순위(LimitRTPRIO)**가 적용되어 실행 안정성을 보장받습니다.

### 2.2. Non-RT 프로세스 (`mxrc-nonrt`)

- **진입점**: `src/nonrt_main.cpp`
- **핵심 컴포넌트**: `NonRTExecutive`, `DataStore`
- **주요 책임**:
    - 복잡하고 비동기적인 작업 처리 (예: 로깅, 모니터링, 외부 시스템과의 통신).
    - `DataStore`를 통해 시스템의 전반적인 상태 관리.
    - RT 프로세스로부터 공유 메모리를 통해 데이터를 수신하고, 필요한 명령을 전송.
    - 자체 하트비트를 주기적으로 갱신하여 자신의 동작 상태를 RT 프로세스에 알림.
- **실행 환경**:
    - `systemd` 서비스(`mxrc-nonrt.service`)를 통해 실행되며, RT 프로세스가 시작된 후에 실행되도록 의존성이 설정되어 있습니다.

## 3. 프로세스 간 통신 (Inter-Process Communication, IPC)

### 3.1. 메커니즘: POSIX 공유 메모리 (Shared Memory)

두 프로세스 간의 통신은 **POSIX 공유 메모리**를 통해서만 독점적으로 이루어집니다.

- **식별자**: `/mxrc_shm`
- **초기화**: RT 프로세스가 공유 메모리 세그먼트를 **생성**합니다.
- **연결**: Non-RT 프로세스는 이미 생성된 공유 메모리 세그먼트에 **연결**하여 사용합니다.

### 3.2. 데이터 구조 (`SharedMemoryData.h`)

공유 메모리에 기록되는 데이터 구조는 `src/core/rt/ipc/SharedMemoryData.h`에 정의되어 있으며, 주요 구성 요소는 다음과 같습니다.

- `RTToNonRT data`: RT 프로세스가 Non-RT 프로세스로 전달하는 데이터.
- `NonRTToRT data`: Non-RT 프로세스가 RT 프로세스로 전달하는 데이터.
- `std::atomic<uint64_t> rt_heartbeat_ns`, `nonrt_heartbeat_ns`: 각 프로세스의 생존 여부를 확인하기 위한 나노초 단위의 타임스탬프.
- `std::atomic<uint64_t> rt_seq`, `nonrt_seq`: 데이터의 최신 여부를 확인하고 데이터 무결성을 보장하기 위한 시퀀스 번호.

### 3.3. 동기화 및 무결성

- **폴링 (Polling)**: 각 프로세스는 상대방의 데이터를 읽기 위해 주기적으로 공유 메모리를 폴링합니다.
- **시퀀스 번호 (Sequence Number)**: 데이터 쓰기가 완료될 때마다 시퀀스 번호를 증가시킵니다. 데이터 읽기 전후로 시퀀스 번호를 확인하여, 읽는 도중 데이터가 변경되지 않았는지(torn-read) 검증합니다.
- **원자적 하트비트 (Atomic Heartbeat)**: `std::atomic`으로 선언된 하트비트 변수를 사용하여, 멀티코어 환경에서도 안전하게 생존 신호를 주고받습니다.

## 4. 프로세스 내부 통신 (Intra-Process Communication)

- **EventBus**: `src/core/event/core/EventBus.h`에 정의된 `EventBus`는 **프로세스 내부(intra-process)**의 컴포넌트 간 통신을 위한 발행-구독(pub-sub) 메커니즘입니다. 이는 프로세스 간 통신(IPC)에는 사용되지 않습니다.

## 5. 시스템 실행 및 관리 (System Execution and Management)

- **Systemd 서비스**: `systemd/` 디렉토리의 `.service` 파일들은 두 프로세스의 실행 순서, 재시작 정책, 자원 할당(CPU, 우선순위)을 관리하여 시스템 전체의 안정성을 보장합니다. `mxrc-nonrt.service`는 `mxrc-rt.service`에 대한 `Requires` 및 `After` 의존성을 가져, 항상 RT 프로세스가 먼저 실행되도록 보장합니다.

## 6. 아키텍처 평가 (Architecture Evaluation)

### 6.1. 장점 (Pros)

- **안정성 및 신뢰성**: Non-RT 프로세스의 복잡성, 버그 또는 크래시가 RT 프로세스의 결정론적 실행에 영향을 주지 않아 시스템 안정성이 높습니다.
- **명확한 책임 분리**: 각 프로세스의 역할이 명확하여 코드의 이해와 유지보수가 용이합니다.
- **성능 보장**: RT 프로세스는 OS 스케줄러로부터 높은 우선순위를 보장받아 정해진 시간 안에 작업을 완료할 수 있습니다.

### 6.2. 단점 및 고려사항 (Cons and Considerations)

- **통신 복잡성**: 공유 메모리를 직접 사용하는 방식은 데이터 구조가 변경될 때마다 양쪽 프로세스를 모두 수정하고 다시 컴파일해야 하는 불편함이 있습니다.
- **폴링 오버헤드**: 높은 빈도의 폴링은 CPU 자원을 지속적으로 소모할 수 있으며, 데이터 변경이 없을 때도 불필요한 검사를 수행합니다.
- **확장성 제약**: 공유할 데이터의 종류가 늘어날수록 `SharedMemoryData.h` 구조체가 비대해지고 관리하기 어려워집니다.
- **데이터 일관성**: 현재의 시퀀스 번호 방식은 단순한 데이터 교환에는 효과적이지만, 복잡한 상태 전이나 트랜잭션 처리가 필요할 경우 추가적인 동기화 메커니즘이 필요할 수 있습니다.

## 7. 결론 및 권장사항 (Conclusion and Recommendations)

현재의 듀얼 프로세스 아키텍처는 RT 시스템의 안정성과 예측 가능성을 보장하기 위한 효과적인 설계입니다. 공유 메모리와 폴링을 사용한 IPC는 단순하고 직접적인 데이터 교환에 적합합니다.

향후 시스템 확장 및 유지보수성 향상을 위해 다음과 같은 개선안을 고려할 수 있습니다.

1.  **데이터 직렬화 포맷 도입**: 공유 메모리 내에서 `Protocol Buffers`, `FlatBuffers` 같은 데이터 직렬화 라이브러리를 사용하여 데이터 구조 변경에 유연하게 대응하고, 버전 관리를 용이하게 할 수 있습니다.
2.  **IPC 메커니즘 보완**: 현재의 공유 메모리 방식과 더불어, 복잡한 이벤트나 명령 전달을 위해 **ZeroMQ(ZMQ)**나 **POSIX Message Queues**와 같은 메시지 큐 시스템을 도입하는 것을 고려할 수 있습니다. 이는 폴링 오버헤드를 줄이고, 보다 유연한 통신 패턴(예: pub-sub, req-rep)을 구현하는 데 도움이 됩니다.
3.  **이벤트 기반 동기화**: 폴링의 CPU 소모가 문제가 될 경우, 공유 메모리와 함께 **세마포어(semaphore)**나 **조건 변수(condition variable)**를 사용하여 이벤트 기반의 알림(notification) 메커니즘을 구현하여 CPU 사용량을 최적화할 수 있습니다.
