
# 아키텍처 및 로깅 시스템 평가

- **문서 ID**: `005-architecture-and-logging-evaluation`
- **작성일**: 2025-11-21
- **상태**: 분석 완료

## 1. 개요

본 문서는 MXRC 프로젝트의 현재 시스템 아키텍처, 특히 프로세스 관리(RT/Non-RT)와 로깅 시스템의 통합 관점에서 평가하고 개선점을 도출하는 것을 목표로 한다. 분석은 `dev/agent/GEMINI.md` 가이드라인과 현재 프로젝트 구조를 기반으로 한다.

## 2. 현 시스템 구성 평가

### 2.1. 프로세스 관리 (RT/Non-RT)

#### 현황
- **프로세스 분리**: 시스템은 실시간(RT) 프로세스(`rt_main.cpp`)와 비실시간(Non-RT) 프로세스(`nonrt_main.cpp`)로 명확히 분리되어 있다.
- **서비스 관리**: `systemd` 서비스 파일(`mxrc-rt.service`, `mxrc-nonrt.service`)을 통해 각 프로세스가 독립적인 서비스로 관리된다. 이는 프로세스의 생명주기 관리와 자원 격리에 매우 효과적인 접근 방식이다.
- **아키텍처**: `PREEMPT_RT` 커널 사용을 전제로 하여, RT 프로세스는 결정성(determinism)이 요구되는 작업을, Non-RT 프로세스는 로깅, 복잡한 연산, 외부 통신 등 비결정적 지연을 유발할 수 있는 작업을 처리하도록 설계되었다.

#### 긍정적 평가
- **안정성 및 신뢰성**: RT와 Non-RT 프로세스의 분리는 Non-RT 프로세스의 오류(예: 크래시, 높은 CPU 점유)가 RT 태스크의 실행에 영향을 주지 않도록 보장한다. 이는 시스템의 전체적인 안정성을 크게 향상시킨다.
- **자원 격리**: OS 수준에서 각 프로세스에 다른 CPU 코어, 우선순위, 메모리 정책을 할당할 수 있어 RT 작업의 실행 시간을 보장하는 데 유리하다.
- **명확한 책임 분리**: `src/core/rt`와 `src/core/nonrt` 디렉토리 구조는 각 프로세스의 역할을 명확히 구분하여 코드의 유지보수성을 높인다.

#### 개선점 파악
1.  **프로세스 간 통신(IPC) 메커니즘의 구체화 부재**:
    - 현재 두 프로세스가 어떻게 데이터를 교환하는지에 대한 명시적인 아키텍처 정의가 부족하다. IPC 방식(공유 메모리, 메시지 큐 등)의 선택은 전체 시스템 성능과 안정성에 큰 영향을 미친다.
    - IPC의 성능 병목, 데이터 동기화, 오류 처리(예: 한쪽 프로세스가 다운되었을 때)에 대한 고려가 필요하다.

2.  **상호 헬스 체크(Health Check) 메커니즘 부재**:
    - 한 프로세스가 다른 프로세스의 상태를 모니터링하는 'Heartbeat'과 같은 메커니즘이 없다면, 한쪽의 비정상 종료나 멈춤 상태를 다른 쪽이 인지하기 어렵다. 이는 시스템 전체의 가용성을 저해할 수 있다.

3.  **데이터 및 설정 동기화의 복잡성**:
    - 두 프로세스가 공유해야 하는 설정이나 데이터의 일관성을 유지하는 메커니즘이 복잡해질 수 있다. 설정 변경 시 두 프로세스에 안전하게 전파하고 적용하는 방안이 필요하다.

### 2.2. 로깅 시스템 통합

#### 현황
- **로깅 라이브러리**: 고성능 로깅 라이브러리인 `spdlog`를 표준으로 채택하고 있다.
- **비동기 로깅**: `docs/issue/006-spdlog-async-refactor.md`에서 언급되었듯이 비동기 로깅으로 리팩토링이 진행되었다. 이는 로깅 호출이 애플리케이션의 주요 로직을 블로킹하지 않도록 하는 중요한 개선이다.
- **전용 모듈**: `src/core/logging` 디렉토리를 통해 로깅 관련 기능이 모듈화되어 있다.

#### 긍정적 평가
- **고성능 로깅**: `spdlog` 사용은 로깅으로 인한 성능 저하를 최소화하는 좋은 선택이다.
- **블로킹 방지**: 비동기 로깅을 도입하여 Non-RT 프로세스의 성능을 향상시켰다.

#### 개선점 파악
1.  **분산된 로그 파일**:
    - 현재 구조상 RT 프로세스와 Non-RT 프로세스가 각각 별도의 로그 파일에 로그를 기록할 가능성이 높다. 이 경우, 전체 시스템의 동작을 시간 순으로 재구성하여 분석하기 매우 어렵다.

2.  **RT 프로세스의 로깅 방식 위험성**:
    - 만약 RT 프로세스에서 `spdlog`의 비동기 로거를 사용하더라도, 내부적으로 파일 I/O와 관련된 시스템 콜을 호출하게 된다. `PREEMPT_RT` 환경에서 RT 스레드가 파일 I/O와 같은 블로킹 연산을 수행하는 것은 **심각한 안티패턴**이며, 우선순위 역전(Priority Inversion)을 유발하여 실시간성을 해칠 수 있다.
    - RT 프로세스는 로그 메시지를 실시간 제약에 안전한(lock-free) 공유 메모리 링 버퍼(Ring Buffer)에 기록하고, Non-RT 프로세스가 이를 읽어 파일에 쓰는 방식이 이상적이다.

3.  **구조화된 로깅(Structured Logging)의 부재**:
    - 로그가 단순 텍스트 형식이라면 로그 분석 및 모니터링 시스템(예: ELK, Grafana Loki)과의 연동이 비효율적이다. JSON과 같은 구조화된 형식으로 로그를 남기면, 필터링, 집계, 시각화가 훨씬 용이해진다.

4.  **동적 로그 레벨 제어의 부재**:
    - 시스템 운영 중 특정 모듈의 디버그 로그를 확인하기 위해 서비스를 재시작해야 한다면, 문제 해결에 많은 시간이 소요된다. IPC 등을 통해 런타임에 동적으로 로그 레벨을 변경하는 기능이 필요하다.

## 3. 개선 제안

### 3.1. 프로세스 관리 강화
- **IPC 메커니즘 표준화**: TBB의 `concurrent_queue`나 lock-free 공유 메모리 큐 등을 사용하여 두 프로세스 간의 통신 방식을 표준화하고, 성능 및 안정성을 문서화한다.
- **Heartbeat 도입**: 각 프로세스가 주기적으로 자신의 상태를 알리는 Heartbeat 메시지를 IPC를 통해 교환하여, 상대방의 상태를 지속적으로 확인하고 비정상 상황에 대응하는 로직을 추가한다.
- **중앙 설정 관리자 도입**: Non-RT 프로세스에 설정 관리자를 두어, 설정 변경 시 IPC를 통해 RT 프로세스에 안전하게 전파하는 메커니즘을 구현한다.

### 3.2. 로깅 시스템 고도화
- **RT 프로세스 로깅 리팩토링 (가장 중요)**:
    - RT 프로세스는 로그 메시지를 **실시간 안전(real-time safe) 공유 메모리 링 버퍼**에만 쓰도록 제한한다.
    - Non-RT 프로세스에 'Log Consumer' 스레드를 추가하여, 이 링 버퍼에서 로그를 읽어 `spdlog`를 통해 파일이나 네트워크로 비동기적으로 기록하도록 아키텍처를 변경한다.

- **중앙화된 로그 수집기 도입**:
    - Non-RT 프로세스가 모든 로그(자신의 로그 + RT 프로세스로부터 받은 로그)를 통합하여 단일 채널(파일 또는 네트워크 소켓)로 출력하도록 구성한다. 이는 로그 분석을 크게 단순화한다.

- **JSON 포맷터 도입**: `spdlog`의 커스텀 포맷터를 활용하여 모든 로그를 JSON 형식으로 출력하도록 표준화한다. (예: `{"timestamp": "...", "level": "info", "source": "rt_motor_control", "message": "...", "value": 123}`).

- **런타임 로그 레벨 제어 구현**: IPC를 통해 Non-RT 프로세스가 RT 프로세스의 특정 모듈에 대한 로그 레벨을 동적으로 변경할 수 있는 커맨드 인터페이스를 추가한다.

## 4. 결론

MXRC 프로젝트는 RT/Non-RT 프로세스 분리를 통해 안정성과 신뢰성을 위한 훌륭한 기반을 갖추고 있다. 그러나 프로덕션 레벨의 견고함과 관측 가능성(Observability)을 확보하기 위해서는 프로세스 간의 상호작용(IPC, 헬스 체크)을 더욱 구체화하고, 특히 **RT 프로세스의 로깅 방식을 실시간 제약에 안전하도록 시급히 재설계**해야 한다. 또한, 구조화 및 중앙화된 로깅 시스템을 도입하여 유지보수 및 문제 해결 능력을 대폭 향상시킬 필요가 있다.
