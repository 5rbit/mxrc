### 아키텍처 분석: 문제점 및 개선 제안

전반적으로 이 아키텍처는 실시간 시스템의 안정성과 비실시간 시스템의 유연성을 모두 확보하기 위한 강력하고 검증된 **듀얼 프로세스 패턴**을 채택하고 있습니다. 이는 매우 훌륭한 설계입니다.

아래 분석은 현재 구조를 비판하는 것이 아니라, 시스템을 더욱 견고하고 확장 가능하게 만들기 위한 구체적인 제안입니다.

---

#### 1. `DataStore` (중앙 공유 저장소)의 잠재적 위험

`DataStore`는 프로세스 간 데이터 공유를 위한 핵심 요소이지만, 시스템의 복잡성이 증가할수록 몇 가지 잠재적인 문제점을 가질 수 있습니다.

*   **문제점 1: 암묵적인 결합 (Implicit Coupling) 및 God Object화**
    *   **현상**: 모든 데이터가 `DataStore`에 집중되면서, 어떤 모듈이 어떤 데이터를 생성하고 소비하는지에 대한 소유권이 불분명해질 수 있습니다. 이는 `DataStore`를 일종의 "전역 변수"처럼 만들어 모듈 간의 결합도를 암묵적으로 높입니다.
    *   **영향**: 특정 데이터의 형식을 변경할 때, 해당 데이터를 사용하는 모든 모듈을 추적하여 수정해야 하므로 유지보수가 어려워지고, 예상치 못한 부작용이 발생할 수 있습니다.
    *   **개선 제안**:
        *   **데이터 접근자(Accessor) 분리**: `DataStore`에 직접 접근하는 대신, 각 데이터 도메인(예: `SensorDataAccessor`, `RobotStateAccessor`)에 특화된 인터페이스를 제공합니다. 이를 통해 데이터의 소유권을 명확히 하고, 모듈은 자신이 필요한 데이터에만 접근하도록 강제할 수 있습니다.
        *   **데이터 계약(Data Contract) 정의**: `DataStore`에 저장되는 데이터의 키, 타입, 유효 범위 등을 `specs/contracts`와 같은 곳에 명확히 문서화하여 관리합니다.

*   **문제점 2: 복합 트랜잭션의 부재**
    *   **현상**: RT 프로세스가 여러 상태 값을 순차적으로 업데이트하는 동안, Non-RT 프로세스가 그 중간 상태를 읽어갈 경우 데이터 불일치(Inconsistency)가 발생할 수 있습니다. (예: 로봇의 `상태`는 `Moving`으로 바뀌었지만, `목표 좌표`는 아직 이전 값인 상태)
    *   **영향**: 시스템이 일관되지 않은 상태에 빠져 오작동하거나, Non-RT 모듈(모니터링 등)이 사용자에게 잘못된 정보를 표시할 수 있습니다.
    *   **개선 제안**:
        *   **버전 관리 또는 시퀀스 번호 도입**: `DataStore`의 모든 데이터 묶음에 버전 번호(또는 시퀀스 번호)를 부여합니다. 데이터를 읽는 쪽은 버전 번호를 함께 확인하여, 여러 데이터가 원자적으로(atomically) 갱신되었는지 검증할 수 있습니다.
        *   **Shadow Copy / Double Buffering**: 중요한 데이터 구조에 한해, RT 프로세스가 '백그라운드 복사본'에 모든 변경을 완료한 후, 포인터(또는 인덱스) 하나만 바꿔서 '활성 복사본'으로 전환하는 기법을 고려할 수 있습니다.

---

#### 2. `EventBus` (IPC 메시지 큐)의 안정성

`EventBus`는 비동기 통신에 효과적이지만, 두 프로세스의 처리 속도 차이로 인해 병목 현상이 발생할 수 있습니다.

*   **문제점: 이벤트 과부하(Event Storm) 및 백프레셔(Backpressure) 부재**
    *   **현상**: RT 프로세스는 매우 빠른 속도로 로그나 이벤트를 생성할 수 있지만, 파일 I/O나 네트워크 통신을 하는 Non-RT 프로세스의 소비 속도는 그보다 느릴 수 있습니다. 특정 장애 상황에서는 이벤트가 폭발적으로 증가("Event Storm")할 수 있습니다.
    *   **영향**: 메시지 큐가 가득 차면, 새로운 이벤트를 버리거나(데이터 유실), 최악의 경우 RT 프로세스가 이벤트를 보내기 위해 대기(블로킹)하게 되어 실시간성을 해칠 수 있습니다.
    *   **개선 제안**:
        *   **메시지 우선순위 큐 도입**: 모든 이벤트를 동일하게 취급하지 않고, '치명적 오류', '상태 변경' 등 중요 이벤트에 높은 우선순위를 부여하여 큐가 가득 찼을 때 낮은 우선순위의 로그부터 버리도록 설계합니다.
        *   **이벤트 Coalescing/Throttling**: 짧은 시간 내에 동일한 이벤트가 반복적으로 발생할 경우, 이를 하나로 병합하거나(Coalescing) 발생 빈도를 조절(Throttling)하는 메커니즘을 Non-RT 수신단에 구현합니다. (예: "온도 센서 연결 끊김" 이벤트를 1ms마다 보내는 대신, 1초에 한 번만 보내도록 조절)
        *   **SPSC 큐 용량 및 정책 명시**: Boost.Lockfree SPSC 큐의 용량(capacity)과 큐가 가득 찼을 때의 동작(오래된 것부터 버릴지, 새 것을 버릴지)을 아키텍처 문서에 명확히 정의합니다.

---

#### 3. `HA` (고가용성) 모듈의 복잡성

HA 모듈은 시스템 안정성의 핵심이지만, 그 자체로 또 다른 실패 지점(Single Point of Failure)이 될 수 있습니다.

*   **문제점: 스플릿 브레인(Split-Brain) 시나리오**
    *   **현상**: RT와 Non-RT 프로세스 간의 하트비트 통신 채널(IPC)에만 문제가 생기고, 두 프로세스는 정상 동작 중인 상황이 발생할 수 있습니다. 이 경우, 양쪽 프로세스는 서로 상대방이 비정상이라고 판단하여 동시에 복구 로직(재시작 등)을 수행하려 할 수 있습니다.
    *   **영향**: 시스템이 예측 불가능한 상태에 빠지거나, 두 프로세스가 서로를 계속 재시작시키며 무한 루프에 빠질 수 있습니다.
    *   **개선 제안**:
        *   **제3의 감시자(Arbiter/Quorum) 도입**: 단순히 양자 간의 하트비트만 확인하는 것이 아니라, 시스템의 최종 상태를 결정하는 제3의 독립적인 감시 메커니즘(예: systemd의 `WatchdogSec` 기능, 또는 별도의 경량 프로세스)을 도입하여 스플릿 브레인을 방지합니다.
        *   **HA 정책 상세화**: 복구 시나리오(예: 'RT 장애 시 Non-RT는 즉시 시스템을 안전 모드로 전환', 'Non-RT 장애 시 RT는 단독으로 최소 기능 수행')를 매우 구체적으로 정의하고 문서화해야 합니다.

---

### 요약: 개선점 제안 테이블

| 영역 | 문제점 | 영향 | 개선 제안 |
| :--- | :--- | :--- | :--- |
| **DataStore** | God Object화, 암묵적 결합 | 유지보수성 저하, 부작용 위험 | 데이터 도메인별 접근자(Accessor) 분리, 데이터 계약 정의 |
| | 복합 트랜잭션 부재 | 데이터 불일치, 시스템 오작동 | 데이터 버전/시퀀스 번호 도입, Shadow Copy/Double Buffering 검토 |
| **EventBus** | 이벤트 과부하, 백프레셔 부재 | 데이터 유실, RT 성능 저하 | 우선순위 큐 도입, 이벤트 Coalescing/Throttling, 큐 정책 명시 |
| **HA** | 스플릿 브레인(Split-Brain) | 예측 불가능한 시스템 상태 | 제3의 감시자(Arbiter) 도입, systemd Watchdog 활용, 상세한 복구 정책 정의 |

---

#### 4. `systemd` 통합 및 프로세스 아키텍처

`systemd`를 활용한 프로세스 관리 및 RT/Non-RT 아키텍처는 매우 정교하지만, 서비스 시작 순서에 치명적인 결함이 존재합니다.

*   **문제점: 시작 시 경쟁 상태 (CRITICAL Race Condition)**
    *   **현상**: `systemd` 서비스 설정(`mxrc-rt.service`의 `After=mxrc-nonrt.service`)에 따라 `nonrt` 프로세스가 `rt` 프로세스보다 먼저 시작됩니다. 하지만 실제 코드에서는 `rt` 프로세스가 두 프로세스 간의 통신 채널인 공유 메모리(`shm`)를 **생성**하고, `nonrt` 프로세스는 이미 생성된 `shm`을 **열려고** 시도합니다. `nonrt`가 `rt`보다 먼저 실행되어 `shm` 열기를 시도하면, 해당 파일이 존재하지 않으므로 100% 실패하고 `nonrt` 프로세스는 비정상 종료됩니다.
    *   **영향**: 시스템 시작이 매우 불안정하며, 타이밍에 따라 성공하거나 실패합니다. 이는 프로덕션 환경에서 절대 용납될 수 없는 문제입니다.
    *   **개선 제안**:
        *   **`systemd` 시작 순서 변경 (필수)**: 리소스를 생성하는 `rt` 프로세스가 이를 사용하는 `nonrt` 프로세스보다 먼저 시작되도록 `systemd` 종속성을 수정해야 합니다.
            *   `mxrc-nonrt.service`: `After=mxrc-rt.service` 및 `Wants=mxrc-rt.service` 추가
            *   `mxrc-rt.service`: `nonrt`에 대한 종속성 제거 후, `Before=mxrc-nonrt.service` 추가
        *   **`nonrt` 초기화 안정성 강화**: `nonrt` 프로세스의 `init()` 함수에 재시도 로직을 추가하여, 공유 메모리가 즉시 사용 가능하지 않더라도 몇 초간 대기하며 연결을 시도하도록 만듭니다. 이는 시스템의 전반적인 안정성을 크게 향상시킵니다.

*   **강점: 고급 `systemd` 기능 활용**
    *   **프로세스 격리 및 실시간 설정**: `CPUAffinity`, `CPUSchedulingPolicy`, `LimitMEMLOCK` 등을 정확하게 사용하여 RT 프로세스의 실시간성을 보장하고 다른 프로세스와의 간섭을 최소화했습니다.
    *   **상태 감시 및 복원력**: `WatchdogSec`과 `sd_notify`를 이용한 하트비트 메커니즘은 `rt` 프로세스가 멈추거나 응답하지 않을 때 `systemd`가 자동으로 복구할 수 있게 하는 매우 강력한 기능입니다.
    *   **보안 및 리소스 관리**: `NoNewPrivileges`, `ProtectSystem`, `CPUQuota` 등 `systemd`의 보안 및 리소스 제한 기능을 적극적으로 활용하여 시스템을 안정적이고 안전하게 만듭니다.

---

### 최종 요약: 개선점 제안 테이블 (추가)

| 영역 | 문제점 | 영향 | 개선 제안 |
| :--- | :--- | :--- | :--- |
| **Systemd** | **시작 순서 경쟁 상태** | **시스템 시작 실패, 불안정** | **`systemd` 서비스 종속성 수정 (rt 우선 시작), `nonrt`에 재시도 로직 추가** |