# MXRC 아키텍처 분석 및 개선 제안

## 1. 개요

본 문서는 MXRC(Mission and eXecution Robot Controller) 프로젝트의 현재 아키텍처를 분석하고, 향후 유지보수성, 성능, 안정성 향상을 위한 개선 방안을 제안하는 것을 목표로 한다.

### 1.1. 종합 평가

MXRC는 로봇 제어 시스템으로서 매우 성숙하고 잘 설계된 프로젝트이다. 특히 아래와 같은 강점을 가지고 있다.

-   **명확한 아키텍처**: 실시간(RT)과 비실시간(Non-RT) 프로세스를 분리한 듀얼-프로세스 아키텍처는 제어 시스템의 안정성과 예측 가능성을 보장하는 핵심적인 설계이다.
-   **계층적 설계**: Task → Sequence → Action으로 이어지는 3계층 실행 구조는 각 컴포넌트의 책임을 명확히 분리하여 코드의 모듈성과 테스트 용이성을 높인다.
-   **최신 C++ 적용**: RAII, 스마트 포인터, 동시성 라이브러리(TBB, Boost.Lockfree) 등 최신 C++ 기능을 적극적으로 활용하여 메모리 안전성과 성능을 확보하고 있다.
-   **우수한 문서화 및 테스트**: `GEMINI.md`와 같은 AI 개발 가이드, 상세한 `architecture.md` 문서, 그리고 높은 커버리지의 유닛/통합 테스트는 프로젝트의 품질을 크게 향상시킨다.

따라서 본 제안은 기존 아키텍처의 전면적인 수정보다는, 현재의 강점을 더욱 강화하고 잠재적인 리스크를 줄이는 방향에 초점을 맞춘다.

### 1.2. 주요 개선 방향

-   **성능 최적화**: 데이터 경로의 병목 현상 해소 및 RT-safe 보장 강화.
-   **안전성 및 견고성**: 모듈 간의 계약(contract)을 명확히 하여 잠재적 오류 감소.
-   **유지보수성 및 확장성**: 코드의 가독성 및 재사용성 증진.

---

## 2. 아키텍처 분석 및 제안

### 2.1. 듀얼-프로세스 아키텍처 및 IPC

-   **현재 구조**: RT/Non-RT 프로세스 분리는 매우 효과적이다. 공유 메모리 기반의 `DataStore`와 메시지 큐 기반의 `EventBus`를 통한 IPC 방식은 성능과 유연성의 균형을 잘 맞추고 있다.
-   **개선 제안**: **IPC 계약(Contract)의 공식화**
    -   `DataStore`에 사용되는 키(key)들과 `EventBus`를 통해 전달되는 이벤트 타입을 별도의 스키마 파일(예: YAML, JSON, 또는 Protobuf/FlatBuffers IDL)로 명시적으로 정의하는 것을 제안한다.
    -   **기대 효과**:
        -   **컴파일 타임 검증**: 스키마로부터 C++ 헤더를 자동 생성하여 키 문자열 오타나 잘못된 이벤트 페이로드 사용을 컴파일 시점에 방지할 수 있다.
        -   **명확한 문서화**: 두 프로세스 간에 어떤 데이터와 이벤트가 오가는지 명확히 문서화되어 시스템을 이해하기 쉬워진다.
        -   **버전 관리**: 향후 IPC 데이터 구조가 변경될 때 버전 관리가 용이해진다.

### 2.2. 실행 계층 (Task → Sequence → Action)

-   **현재 구조**: 책임 분리가 명확한 훌륭한 계층 구조이다. `ExecutionContext`를 통해 Action 간 데이터를 공유하는 방식은 유연하지만, 암묵적인 의존성을 만들 수 있다.
-   **개선 제안**: **`ExecutionContext`의 구조화**
    -   현재의 자유로운 key-value 방식 대신, 각 시퀀스나 태스크가 필요로 하는 데이터의 종류와 타입을 명시하는 `ContextSpec`과 같은 개념을 도입할 수 있다.
    -   **기대 효과**:
        -   **가독성 향상**: 어떤 Action이 어떤 데이터를 생산하고 소비하는지 명확해진다.
        -   **안전성 강화**: 정해진 스펙 외의 데이터 접근을 제한하여 예기치 않은 부작용을 줄일 수 있다.

### 2.3. DataStore 및 Accessor 패턴

-   **현재 구조**: "God Object"를 리팩토링하고 타입-세이프한 Accessor 패턴을 도입한 것은 매우 긍정적인 변화이다. `tbb::concurrent_hash_map` 사용 역시 좋은 선택이다.
-   **개선 제안 1**: **고성능 키(Hot Key)에 대한 Lock-Free 구현 탐색**
    -   `architecture.md`에 명시된 Getter/Setter 성능 목표(<60ns/<110ns)를 달성하기 위해, 가장 빈번하게 접근되는 데이터(예: 로봇의 현재 위치, 속도)에 대해서는 별도의 Lock-Free 자료구조(예: `std::atomic`으로 직접 관리되는 POD 구조체)를 적용하는 것을 고려할 수 있다.
-   **개선 제안 2**: **`VersionedData` 일관성 검증 로직 단순화**
    -   Non-RT 프로세스에서 torn-read를 방지하기 위해 사용하는 do-while 루프는 보일러플레이트 코드가 될 수 있다. 이 로직을 `DataStore`나 Accessor 내부에 캡슐화하여 `read_consistent()`와 같은 단일 메서드로 제공하는 것을 검토할 수 있다.
    -   **기대 효과**: 사용 편의성을 높이고, 개발자가 일관성 체크를 누락하는 실수를 방지한다.

---

## 3. 모듈별 분석 및 제안

### 3.1. `core/ethercat`

-   **현재 구조**: 기능적으로 잘 구현되어 있으나, EtherCAT 프로토콜 자체의 복잡성으로 인해 모듈의 복잡도가 높다.
-   **개선 제안**: **필드버스(Fieldbus) 추상화 계층 도입**
    -   `IEtherCATMaster`를 넘어, `IFieldbus`와 같은 더 일반적인 인터페이스를 정의하고, EtherCAT은 그 구현체 중 하나가 되도록 구조를 변경할 수 있다.
    -   **기대 효과**: 향후 EtherCAT 외에 다른 필드버스(예: EtherNet/IP, CANopen)를 지원해야 할 경우, 상위 레벨의 코드를 재사용하며 확장성을 크게 높일 수 있다.

### 3.2. `core/logging`

-   **현재 구조**: `Bag` 로깅 시스템은 데이터 기록 및 재생에 매우 강력한 기능이다.
-   **개선 제안**: **Bag 데이터 분석 및 시각화 도구 개발**
    -   기록된 `Bag` 파일을 분석하고, 특정 데이터를 필터링하거나 그래프로 시각화하는 별도의 유틸리티를 개발하면 디버깅 및 시스템 분석 효율이 극대화될 것이다.
    -   **기대 효과**:
        -   **디버깅 효율 증대**: 시스템 장애 발생 후, Bag 파일을 분석하여 원인을 빠르게 파악할 수 있다.
        -   **테스트 자동화**: 기록된 데이터를 기반으로 회귀(regression) 테스트 케이스를 자동으로 생성하는 데 활용할 수 있다.

### 3.3. `core/ha` (고가용성)

-   **현재 구조**: 프로세스 간 하트비트 교환을 통한 기본적인 모니터링 기능이 구현되어 있다.
-   **개선 제안**: **고가용성 정책의 고도화**
    -   단순히 프로세스 재시작을 넘어, 시스템 상태에 따른 '안전 모드 진입', '부분 기능 재시작', '경고 후 수동 개입 대기' 등 다양한 복구 전략을 수행할 수 있는 정교한 상태 머신(State Machine)을 도입할 수 있다.
    -   **기대 효과**: 시스템의 견고성과 신뢰성을 한 단계 높여, 실제 운영 환경에서 발생할 수 있는 다양한 예외 상황에 더 유연하게 대처할 수 있다.

---

## 4. 요약 및 권장 사항

1.  **IPC 계약 공식화**: `DataStore` 키와 `EventBus` 이벤트를 IDL(e.g., YAML/JSON)로 정의하고 코드를 자동 생성하여, 컴파일 타임에 안전성을 확보하고 명시적인 문서화를 제공한다.
2.  **DataStore 성능 목표 달성**: 가장 접근이 잦은 데이터에 대해 Lock-Free 자료구조를 적용하여, 나노초(nanosecond) 수준의 성능 목표를 달성한다.
3.  **Bag 데이터 분석 도구 개발**: Bag 파일의 시각화, 필터링, 분석을 위한 전용 유틸리티를 개발하여 디버깅 및 테스트 효율을 높인다.
4.  **필드버스 추상화**: `core/ethercat` 모듈에 일반적인 필드버스 인터페이스를 도입하여 향후 다른 통신 프로토콜로의 확장을 용이하게 한다.
5.  **고가용성(HA) 정책 고도화**: 단순 재시작을 넘어, 다양한 장애 시나리오에 대응할 수 있는 정교한 상태 머신 기반의 복구 정책을 구현한다.
