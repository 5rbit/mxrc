# 리서치: TaskManager 모듈 리팩터링

**날짜**: 2025-11-13
**작성자**: Gemini

## 개요

본 문서는 `TaskManager` 모듈 리팩터링을 위한 사전 리서치 결과를 요약합니다. 리팩터링의 목표는 `TaskManager`의 과도한 책임을 분리하고, 아키텍처를 개선하여 유지보수성과 확장성을 높이는 것입니다.

## 리서치 주제 및 결정

### 주제 1: `TaskManager` 책임 분리 방안

- **문제**: `TaskManager` 클래스가 Task 정의 관리, 실행 생명주기 관리, 상태 업데이트 등 너무 많은 책임을 가지고 있어 God Object가 될 우려가 있습니다.
- **리서치 내용**: 이 문제에 대한 일반적인 디자인 패턴(단일 책임 원칙, Strategy Pattern, 등)을 검토했습니다.
- **결정**: **`TaskDefinitionRegistry`**와 **`TaskExecutor`** 클래스를 도입하여 `TaskManager`의 책임을 분리합니다.
- **근거**:
    - **`TaskDefinitionRegistry`**: Task의 메타데이터(이름, 유형, 생성 함수 등)를 관리하는 책임을 전담합니다. 이를 통해 Task 정의와 실행 로직이 분리됩니다.
    - **`TaskExecutor`**: Task의 실제 실행(스레드 관리, 생명주기 제어)을 책임집니다. 이를 통해 `TaskManager`는 실행 정책의 세부 사항을 알 필요가 없어집니다.
    - 이 접근 방식은 단일 책임 원칙(SRP)을 명확하게 따르며, 각 클래스의 역할을 단순화하여 테스트와 유지보수를 용이하게 합니다.

### 주제 2: `Task`와 `ITask`의 역할 통합

- **문제**: `Task` 클래스는 데이터 컨테이너의 역할을 하고, `ITask` 인터페이스는 실행 로직을 정의하여 역할이 분리되어 있습니다. 이로 인해 `TaskManager`에서 두 종류의 객체를 모두 관리해야 하는 복잡성이 발생합니다.
- **리서치 내용**: 데이터와 행위를 함께 갖는 객체 지향 설계 원칙을 검토했습니다.
- **결정**: `Task` 클래스가 `ITask` 인터페이스를 직접 상속받아 구현하도록 구조를 변경합니다.
- **근거**:
    - `Task` 객체 자체가 실행 가능한(runnable) 객체가 되어 모델이 단순화됩니다.
    - `TaskManager`는 `ITask` 타입의 단일 목록만 관리하면 되므로 복잡성이 감소합니다.
    - 데이터와 그 데이터를 사용하는 행위를 하나의 클래스로 캡슐화하여 응집도를 높입니다.

### 주제 3: 상태 관리 개선

- **문제**: `ITaskManager` 인터페이스에 `updateTaskStatus`와 같은 메서드가 노출되어 있어, 외부에서 Task의 상태를 직접 변경할 수 있어 상태 무결성을 해칠 위험이 있습니다.
- **리서치 내용**: 캡슐화 및 상태 패턴(State Pattern)을 검토했습니다.
- **결정**: Task의 상태 변경은 Task 내부에서만 수행되도록 캡슐화를 강화합니다. 외부에서는 `cancel()`과 같은 행위만 요청할 수 있습니다.
- **근거**:
    - Task의 상태 전이(state transition)가 내부 로직에 의해서만 제어되므로 상태 무결성이 보장됩니다.
    - 외부 모듈은 Task의 내부 상태 변화에 대해 알 필요가 없으며, 오직 정의된 인터페이스를 통해서만 상호작용하게 되어 결합도가 낮아집니다.

## 결론

제안된 리팩터링 방안은 표준적인 객체 지향 설계 원칙과 디자인 패턴에 기반하고 있으며, 추가적인 기술적 리서치 없이 명확한 구현 경로를 제공합니다. 따라서 별도의 불확실성이나 기술적 난제가 없어 바로 설계 단계로 진행하는 것이 타당합니다.
