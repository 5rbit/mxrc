# 기능 사양서: DataStore 성능 및 안정성 개선

**기능 브랜치**: `017-datastore-performance`
**생성일**: 2025-11-19
**상태**: 초안
**입력**: 사용자 설명: "issue/005-* 에 대해 보완 할거야"
**관련 이슈**: #005 - DataStore 종합 성능 및 안정성 문제

## 사용자 시나리오 및 테스트

### 사용자 스토리 1 - 고동시성 환경에서 안정적인 데이터 접근 (우선순위: P1)

시스템 운영자와 개발자는 높은 동시성 환경(예: 100+ 동시 스레드)에서도 DataStore가 안정적으로 데이터 읽기/쓰기를 처리하고, 예측 가능한 응답 시간을 제공받기를 원합니다.

**이 우선순위인 이유**: 현재 프로덕션 환경에서 가장 심각한 성능 병목 현상을 유발하고 있으며, 사용자 경험에 직접적인 영향을 미칩니다. 글로벌 뮤텍스로 인해 모든 데이터 접근이 직렬화되어 concurrent_hash_map의 성능 이점이 완전히 무효화되고 있습니다.

**독립 테스트**: 100개의 동시 스레드가 1000회씩 get/set 작업을 수행하는 부하 테스트로 완전히 검증 가능하며, 응답 시간과 처리량 개선을 측정할 수 있습니다.

**인수 시나리오**:

1. **주어진 상황** 100개의 동시 스레드가 DataStore에 접근하는 환경에서, **언제** 각 스레드가 1000회의 get/set 작업을 수행할 때, **그러면** 평균 처리 시간이 기존 대비 80% 이상 단축되어야 합니다.

2. **주어진 상황** 성능 메트릭 수집이 활성화된 상태에서, **언제** 다중 스레드가 동시에 데이터를 읽고 쓸 때, **그러면** 메트릭 수집으로 인한 락 경합이 발생하지 않고, 전체 처리량이 선형적으로 증가해야 합니다.

3. **주어진 상황** 실시간 성능 모니터링이 필요한 상황에서, **언제** 운영자가 get_calls, set_calls 등의 메트릭을 조회할 때, **그러면** 메트릭 조회가 데이터 접근 성능에 영향을 주지 않고 즉시 반환되어야 합니다.

---

### 사용자 스토리 2 - 안전한 비동기 알림 처리 (우선순위: P1)

시스템은 데이터 변경 시 등록된 구독자들에게 안전하게 알림을 전달해야 하며, 구독자가 동시에 등록 해제되더라도 크래시 없이 동작해야 합니다.

**이 우선순위인 이유**: 현재 코드에는 dangling pointer 문제가 존재하여 간헐적으로 세그멘테이션 폴트를 유발할 수 있습니다. 이는 프로덕션 환경에서 치명적인 장애를 일으킬 수 있으므로 즉시 해결이 필요합니다.

**독립 테스트**: 다중 스레드 환경에서 구독 등록/해제와 알림 전달을 동시에 수행하는 스트레스 테스트로 완전히 검증 가능하며, 메모리 안전성을 보장합니다.

**인수 시나리오**:

1. **주어진 상황** 여러 스레드가 동시에 Notifier를 등록하고 해제하는 환경에서, **언제** 데이터 변경으로 notify가 호출될 때, **그러면** 모든 활성 구독자는 정확히 한 번씩 알림을 받고, 파괴된 Notifier는 접근되지 않아야 합니다.

2. **주어진 상황** Notifier가 알림을 처리하는 도중, **언제** 다른 스레드가 해당 Notifier를 unsubscribe하려 할 때, **그러면** notify 작업이 완료될 때까지 Notifier의 생명주기가 보장되어야 합니다.

3. **주어진 상황** 장시간 실행되는 스트레스 테스트 환경에서, **언제** 수천 번의 구독/해제/알림 사이클이 발생할 때, **그러면** 메모리 누수나 크래시 없이 안정적으로 동작해야 합니다.

---

### 사용자 스토리 3 - 최적화된 읽기 전용 접근 (우선순위: P2)

개발자는 데이터 정책, 메타데이터 등 읽기 전용 정보를 조회할 때, 쓰기 작업과 상호 차단되지 않고 빠르게 접근할 수 있어야 합니다.

**이 우선순위인 이유**: 현재는 읽기 작업도 독점 락을 사용하여 불필요한 대기가 발생합니다. 다수의 스레드가 메타데이터를 동시에 조회하는 경우가 많으므로 shared_mutex를 사용하면 큰 성능 향상을 기대할 수 있습니다.

**독립 테스트**: 다수의 읽기 스레드와 소수의 쓰기 스레드가 동시에 동작하는 시나리오로 검증 가능하며, 읽기 처리량 향상을 측정할 수 있습니다.

**인수 시나리오**:

1. **주어진 상황** 100개의 스레드가 동시에 메타데이터를 읽고 1개의 스레드가 가끔 업데이트하는 환경에서, **언제** 읽기 작업이 수행될 때, **그러면** 읽기 스레드들은 서로 차단되지 않고 동시에 진행되어야 합니다.

2. **주어진 상황** 데이터 정책 조회가 빈번한 워크로드에서, **언제** hasAccess와 같은 읽기 전용 메서드가 호출될 때, **그러면** 쓰기 작업이 없는 한 즉시 반환되어야 합니다.

---

### 엣지 케이스

- 메트릭 오버플로우: atomic 카운터가 UINT64_MAX에 도달했을 때 어떻게 처리합니까?
  - 기대 동작: Wrap-around 발생, 차분값 계산 시 오버플로우 고려

- 구독자 콜백 예외: Notifier의 notify 콜백에서 예외가 발생했을 때 어떻게 처리합니까?
  - 기대 동작: 해당 구독자만 스킵하고 나머지 구독자에게 계속 알림 전달

- 동시 구독/해제: 같은 ID에 대해 여러 스레드가 동시에 subscribe/unsubscribe할 때 어떻게 됩니까?
  - 기대 동작: 마지막 작업이 승리(last-write-wins), 데이터 경합 없음

- shared_mutex 쓰기 기아: 읽기 요청이 지속적으로 발생할 때 쓰기 요청이 무한정 대기하지 않습니까?
  - 기대 동작: 쓰기 우선 정책으로 기아 방지

## 요구사항

### 기능적 요구사항

- **FR-001**: 시스템은 성능 메트릭(get_calls, set_calls 등)을 lock-free 방식으로 수집해야 합니다.
  - 인수 기준: atomic operations로 구현되어 락 경합 발생하지 않음

- **FR-002**: 시스템은 Notifier의 생명주기를 shared_ptr로 관리하여 dangling pointer를 방지해야 합니다.
  - 인수 기준: 다중 스레드 환경에서 구독/해제 중에도 크래시 없음

- **FR-003**: 시스템은 읽기 전용 메타데이터 접근에 shared_mutex를 사용하여 읽기 병렬성을 지원해야 합니다.
  - 인수 기준: 다중 읽기 스레드가 동시에 진행 가능

- **FR-004**: 시스템은 메트릭 조회 시 데이터 접근 성능에 영향을 주지 않아야 합니다.
  - 인수 기준: 메트릭 읽기가 atomic load로 구현되어 다른 스레드 차단 안 함

- **FR-005**: 시스템은 Notifier 콜백에서 발생한 예외를 격리하여 다른 구독자에게 영향을 주지 않아야 합니다.
  - 인수 기준: try-catch로 감싸서 로깅 후 계속 진행

- **FR-006**: 시스템은 atomic 카운터의 오버플로우를 안전하게 처리해야 합니다.
  - 인수 기준: relaxed memory order로 성능 최적화, wrap-around 허용

- **FR-007**: 시스템은 기존 DataStore API를 변경하지 않고 내부 구현만 개선해야 합니다.
  - 인수 기준: 기존 테스트 코드가 수정 없이 통과

### 주요 엔티티

- **성능 메트릭 (Metrics)**: 시스템의 운영 상태를 나타내는 카운터 집합
  - 속성: get_calls, set_calls, remove_calls (각각 atomic<size_t>)
  - 관계: DataStore 인스턴스마다 하나씩 존재

- **Notifier**: 데이터 변경 시 알림을 받을 구독자
  - 속성: ID, 콜백 함수, 생명주기(shared_ptr로 관리)
  - 관계: DataStore와 N:1 관계 (하나의 DataStore에 여러 Notifier 등록)

- **공유 메타데이터**: 다중 스레드가 자주 읽는 정보
  - 속성: 데이터 정책, 접근 권한 정보
  - 관계: shared_mutex로 보호되며 읽기 우선 접근

## 성공 기준

### 측정 가능한 결과

- **SC-001**: 100개 동시 스레드 환경에서 10,000회 get/set 작업의 평균 처리 시간이 기존 대비 80% 이상 단축되어야 합니다.
  - 측정 방법: 부하 테스트 벤치마크, 개선 전후 비교

- **SC-002**: lock-free 메트릭 수집으로 인해 전체 처리량이 스레드 수에 비례하여 선형적으로 증가해야 합니다.
  - 측정 방법: 1/10/50/100 스레드 환경에서 처리량 측정, 선형성 계수 R² > 0.95

- **SC-003**: 10,000회 이상의 구독/해제/알림 사이클을 수행해도 메모리 누수나 크래시가 발생하지 않아야 합니다.
  - 측정 방법: Valgrind 메모리 검사, 스트레스 테스트 1시간 이상 무중단 실행

- **SC-004**: 읽기 전용 메타데이터 접근 시, 100개의 동시 읽기 스레드가 쓰기 작업 없이 병렬로 진행되어야 합니다.
  - 측정 방법: 스레드 타임라인 분석, 읽기 대기 시간 <1μs

- **SC-005**: 기존 DataStore 테스트 스위트가 수정 없이 100% 통과해야 합니다.
  - 측정 방법: 리그레션 테스트, 모든 기존 테스트 케이스 통과

## 비기능적 요구사항

### 성능

- **NFR-001**: 메트릭 수집 오버헤드는 전체 작업 시간의 1% 미만이어야 합니다.
- **NFR-002**: Notifier 알림 전달 시간은 구독자 수에 선형 비례해야 합니다 (O(N)).
- **NFR-003**: shared_mutex 획득 시간은 평균 1μs 이하여야 합니다.

### 안정성

- **NFR-004**: 72시간 연속 실행 시 메모리 누수가 10MB 이하여야 합니다.
- **NFR-005**: 구독자 콜백 예외로 인한 시스템 중단이 발생하지 않아야 합니다.

### 유지보수성

- **NFR-006**: 코드 변경은 DataStore 내부 구현에만 국한되어야 합니다 (API 변경 없음).
- **NFR-007**: 새로운 메트릭 추가 시 단일 파일 수정으로 가능해야 합니다.

## 가정 사항

- C++17 표준 라이브러리의 atomic, shared_mutex가 타겟 플랫폼에서 지원됩니다.
- 기존 코드가 oneTBB의 concurrent_hash_map을 사용하고 있습니다.
- 메트릭 정확성보다 성능이 우선이므로 relaxed memory order 사용이 허용됩니다.
- Notifier 콜백 실행 시간은 평균 1ms 미만입니다 (긴 작업은 비동기 처리 권장).

## 범위 외

다음 항목들은 이번 개선 범위에 포함되지 않습니다:

- std::any를 std::variant로 전환 (장기 과제로 별도 이슈 처리)
- 데이터 만료 알고리즘 최적화 (Priority Queue 기반, 별도 이슈 처리)
- DataStore API의 근본적인 재설계
- 분산 환경 지원이나 네트워크 동기화

## 기술적 제약사항

- 기존 DataStore를 사용하는 모든 코드와의 하위 호환성 유지
- 헤더 파일의 공개 인터페이스 변경 최소화
- 컴파일 시간 증가 최소화 (헤더 의존성 추가 금지)