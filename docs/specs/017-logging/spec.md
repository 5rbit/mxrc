# 기능 사양서: 강력한 로깅 시스템 (Bag Logging & Replay Infrastructure)

**기능 브랜치**: `017-logging`
**생성일**: 2025-11-19
**상태**: 초안
**입력**: 사용자 설명: "docs/research001-* 을 확인해서 강력한 로깅 시스템을 도입하려고해. 로깅 관련 모듈을 새로 만드는 것을 목표료 한다."
**연구 문서**: `docs/research/001-datastore-bag-logging-evaluation.md`
**범위**: P1-P2 우선순위만 포함 (기본 로깅 + Replay + 선택적 전략)

## 사용자 시나리오 및 테스트 *(필수)*

### 사용자 스토리 1 - 실시간 시스템 상태 영구 기록 (우선순위: P1)

로봇 제어 엔지니어로서, 프로덕션 환경에서 발생한 간헐적 오류를 디버깅하기 위해 시스템의 모든 상태 변화를 타임스탬프와 함께 영구 저장하고 싶습니다. 오류 발생 전후의 정확한 상태 변화를 재현할 수 있어야 합니다.

**이 우선순위인 이유**:
- 프로덕션 환경에서의 디버깅은 현재 불가능함 (데이터 휘발성)
- 간헐적 오류의 근본 원인 분석을 위한 필수 인프라
- 고객사 현장에서 발생한 문제의 재현 및 분석 필수

**독립 테스트**:
DataStore의 주요 데이터 타입(MissionState, TaskState, Alarm, Event)을 변경하면서 Bag 파일이 정상적으로 생성되고, 모든 변경 사항이 타임스탬프와 함께 기록되는지 검증할 수 있습니다. 이 기능만으로도 사후 분석(post-mortem analysis) 가치를 제공합니다.

**인수 시나리오**:

1. **주어진 상황** DataStore에 MissionState가 변경될 때, **언제** 로깅 시스템이 활성화되어 있으면, **그러면** 해당 변경사항이 나노초 정밀도의 타임스탬프와 함께 Bag 파일에 기록됩니다
2. **주어진 상황** 로봇 미션 실행 중 오류가 발생했을 때, **언제** Bag 파일을 열어 오류 발생 1초 전의 시스템 상태를 조회하면, **그러면** 모든 상태 변화가 시간순으로 정렬되어 표시됩니다
3. **주어진 상황** 8시간 동안 로봇을 운영했을 때, **언제** Bag 파일 크기가 1GB를 초과하면, **그러면** 자동으로 새로운 Bag 파일이 생성되고 이전 파일은 보존됩니다
4. **주어진 상황** 로깅 시스템이 비활성화되었을 때, **언제** DataStore가 변경되면, **그러면** 시스템 성능에 영향을 주지 않고 정상 동작합니다
5. **주어진 상황** 7일이 지난 Bag 파일이 있을 때, **언제** 보존 정책(retention policy)에 따라, **그러면** 오래된 파일이 자동으로 삭제됩니다

---

### 사용자 스토리 2 - 복잡한 시나리오 재현 및 회귀 테스트 (우선순위: P2)

테스트 엔지니어로서, 프로덕션 환경에서 성공적으로 수행된 복잡한 미션을 테스트 환경에서 정확히 재현하고, 코드 수정 후 동일한 결과가 나오는지 검증하고 싶습니다.

**이 우선순위인 이유**:
- 복잡한 시나리오의 수동 재현은 시간 소모적이고 오류 발생 가능성 높음
- 회귀 테스트 자동화를 통한 품질 보증 강화
- 코드 리팩토링 시 안전성 확보

**독립 테스트**:
Bag 파일을 읽어서 BagReplayer를 통해 DataStore에 동일한 순서로 데이터를 재생하고, 최종 상태가 원본과 일치하는지 검증할 수 있습니다. P1의 Bag 기록 기능과 독립적으로 Replay 기능을 테스트할 수 있습니다.

**인수 시나리오**:

1. **주어진 상황** 성공적으로 완료된 미션의 Bag 파일이 있을 때, **언제** BagReplayer로 해당 파일을 재생하면, **그러면** 원본과 동일한 순서로 DataStore에 데이터가 복원됩니다
2. **주어진 상황** Bag 파일 재생 중, **언제** 속도 배율(speed factor)을 2.0으로 설정하면, **그러면** 원본보다 2배 빠르게 재생되며 타임스탬프 간격은 유지됩니다
3. **주어진 상황** 코드 수정 후 회귀 테스트를 실행할 때, **언제** 동일한 Bag 파일로 재생하면, **그러면** 최종 MissionState가 원본과 일치하는지 자동으로 검증됩니다
4. **주어진 상황** Bag 파일의 특정 시간 범위만 재생하고 싶을 때, **언제** 시작/종료 시간을 지정하면, **그러면** 해당 구간만 재생됩니다
5. **주어진 상황** 대용량 Bag 파일(1GB 이상)을 열 때, **언제** BagReader로 조회하면, **그러면** 인덱스를 활용하여 10초 이내에 원하는 시점으로 탐색할 수 있습니다

---

### 사용자 스토리 3 - 선택적 로깅 전략 설정 (우선순위: P2)

시스템 관리자로서, 데이터 유형별로 차별화된 로깅 전략을 설정하여 고빈도 데이터는 메모리에만 보관하고, 중요 데이터만 영구 저장함으로써 성능과 저장 공간을 최적화하고 싶습니다.

**이 우선순위인 이유**:
- InterfaceData 같은 고빈도 데이터의 전체 로깅은 성능 저하 위험
- 저장 공간 효율성 확보 (전체 로깅 시 384MB/hour vs 선택적 로깅 시 24MB/hour)
- 실시간 제어 루프의 성능 유지 필수

**독립 테스트**:
각 DataType에 대해 LoggingStrategy를 설정하고, 해당 전략에 따라 데이터가 올바르게 처리되는지(Bag 기록, 순환 버퍼, 무시) 검증할 수 있습니다. P1의 기본 로깅 기능 위에 선택적으로 추가할 수 있는 기능입니다.

**인수 시나리오**:

1. **주어진 상황** InterfaceData를 MEMORY_ONLY 전략으로 설정했을 때, **언제** 데이터가 변경되면, **그러면** Bag 파일에는 기록되지 않고 최근 1000개만 순환 버퍼에 보관됩니다
2. **주어진 상황** MissionState를 FULL_BAG 전략으로 설정했을 때, **언제** 데이터가 변경되면, **그러면** 모든 변경사항이 Bag 파일에 기록됩니다
3. **주어진 상황** Alarm을 EVENT_DRIVEN 전략으로 설정했을 때, **언제** 특정 조건(severity > HIGH)을 만족하는 알람이 발생하면, **그러면** 해당 알람만 Bag 파일에 기록됩니다
4. **주어진 상황** 순환 버퍼에 보관된 InterfaceData를 조회할 때, **언제** 최근 100개를 요청하면, **그러면** 시간순으로 정렬된 최근 100개 데이터가 반환됩니다
5. **주어진 상황** 로깅 전략을 설정 파일로 관리할 때, **언제** 런타임에 설정 파일을 수정하면, **그러면** 재시작 없이 새로운 전략이 적용됩니다

---

### 엣지 케이스

- **디스크 공간 부족**: Bag 파일 쓰기 중 디스크 공간이 부족하면 어떻게 됩니까?
  - 시스템은 경고 로그를 기록하고, 가장 오래된 Bag 파일을 삭제한 후 쓰기를 계속합니다
  - 삭제할 파일이 없으면 쓰기를 중단하고, 시스템은 정상 동작을 유지합니다 (로깅만 비활성화)

- **Bag 파일 손상**: Bag 파일이 손상되었을 때 시스템이 어떻게 처리합니까?
  - BagReader는 손상된 메시지를 건너뛰고 복구 가능한 메시지만 읽습니다
  - 손상 정도를 로그에 기록하고, 사용자에게 경고를 표시합니다

- **비동기 쓰기 큐 오버플로우**: 이벤트 발생 속도가 Bag Writer의 처리 속도를 초과하면?
  - 큐 크기 제한에 도달하면 가장 오래된 메시지를 드롭합니다
  - 드롭된 메시지 수를 통계에 기록하고, 경고 로그를 남깁니다

- **멀티스레드 동시 쓰기**: 여러 스레드에서 동시에 Bag 파일에 쓰려고 하면?
  - AsyncWriter의 큐가 모든 쓰기를 직렬화하여 처리합니다
  - 타임스탬프 순서는 이벤트 발생 시각 기준으로 보장됩니다

- **Replay 중 데이터 불일치**: Bag 파일 재생 중 실제 시스템 동작과 결과가 다르면?
  - 불일치를 감지하여 로그에 기록합니다
  - 테스트 프레임워크는 예상 결과와 실제 결과를 비교하여 실패를 보고합니다

- **순환 버퍼 오버플로우**: InterfaceData가 순환 버퍼 용량을 초과하면?
  - 가장 오래된 데이터를 자동으로 제거하고 새 데이터를 추가합니다 (FIFO)
  - 버퍼 크기는 설정 파일로 조정 가능합니다

## 요구사항 *(필수)*

### 기능적 요구사항

**기본 로깅 인프라 (P1)**

- **FR-001**: 시스템은 DataStore의 모든 변경사항을 나노초 정밀도의 타임스탬프와 함께 기록할 수 있어야 합니다
- **FR-002**: 시스템은 EventBus 기반 비동기 로깅을 지원하여 DataStore의 성능에 영향을 주지 않아야 합니다 (성능 저하 < 1%)
- **FR-003**: 시스템은 Bag 파일을 JSONL(JSON Lines) 포맷으로 저장해야 합니다
- **FR-004**: 시스템은 파일 크기 기반 순환 정책(rotation policy)을 지원해야 합니다 (기본값: 1GB)
- **FR-005**: 시스템은 시간 기반 보존 정책(retention policy)을 지원해야 합니다 (기본값: 7일)
- **FR-006**: 시스템은 컴파일 타임 또는 런타임에 로깅 활성화/비활성화를 선택할 수 있어야 합니다
- **FR-007**: BagWriter는 비동기 I/O를 사용하여 디스크 쓰기가 메인 스레드를 블로킹하지 않아야 합니다
- **FR-008**: 시스템은 로깅 통계(메시지 수, 바이트 수, 드롭된 메시지 수)를 제공해야 합니다

**데이터 직렬화 (P1)**

- **FR-009**: 시스템은 std::any로 저장된 SharedData 값을 JSON으로 직렬화할 수 있어야 합니다
- **FR-010**: 직렬화는 모든 DataType(RobotMode, InterfaceData, Config, Para, Alarm, Event, MissionState, TaskState)을 지원해야 합니다
- **FR-011**: BagMessage 구조체는 timestamp_ns, topic(id), data_type, serialized_value 필드를 포함해야 합니다

**Bag 파일 읽기 및 재생 (P2)**

- **FR-012**: BagReader는 JSONL 포맷의 Bag 파일을 파싱할 수 있어야 합니다
- **FR-013**: BagReader는 타임스탬프 기반으로 특정 시점으로 탐색할 수 있어야 합니다
- **FR-014**: BagReplayer는 Bag 파일의 데이터를 DataStore에 순서대로 복원할 수 있어야 합니다
- **FR-015**: BagReplayer는 재생 속도 배율(0.1x ~ 10x)을 조정할 수 있어야 합니다
- **FR-016**: BagReplayer는 시작/종료 시간을 지정하여 특정 구간만 재생할 수 있어야 합니다

**선택적 로깅 전략 (P2)**

- **FR-017**: 시스템은 DataType별로 차별화된 로깅 전략을 설정할 수 있어야 합니다
- **FR-018**: 로깅 전략은 NONE(로깅 안 함), MEMORY_ONLY(순환 버퍼), EVENT_DRIVEN(조건부), FULL_BAG(전체 로깅)을 지원해야 합니다
- **FR-019**: MEMORY_ONLY 전략은 고정 크기 순환 버퍼를 사용하여 최근 N개의 데이터만 보관해야 합니다 (기본값: 1000)
- **FR-020**: EVENT_DRIVEN 전략은 사용자 정의 조건(predicate)에 따라 선택적으로 로깅해야 합니다
- **FR-021**: 로깅 전략 설정은 설정 파일(JSON/YAML)로 관리할 수 있어야 합니다
- **FR-022**: 순환 버퍼는 getLast(count) 메서드로 최근 데이터를 조회할 수 있어야 합니다

**안정성 및 오류 처리**

- **FR-023**: 디스크 공간 부족 시 시스템은 가장 오래된 Bag 파일을 자동 삭제하고 쓰기를 계속해야 합니다
- **FR-024**: Bag 파일 손상 시 BagReader는 복구 가능한 메시지만 읽고 손상 정도를 로그에 기록해야 합니다
- **FR-025**: 비동기 쓰기 큐가 가득 찰 경우 가장 오래된 메시지를 드롭하고 드롭 카운트를 기록해야 합니다
- **FR-026**: 시스템은 로깅 실패 시에도 정상 동작을 유지해야 합니다 (로깅만 비활성화)

### 주요 엔티티

- **BagMessage**: 로그 파일에 저장되는 단일 메시지 단위
  - timestamp_ns (int64_t): 나노초 정밀도 타임스탬프
  - topic (std::string): DataStore ID
  - data_type (DataType): 데이터 유형 구분
  - serialized_value (std::string): JSON 직렬화된 값

- **IBagWriter**: Bag 파일 쓰기 인터페이스
  - append(): 동기 쓰기 (테스트용)
  - appendAsync(): 비동기 쓰기 (프로덕션)
  - flush(): 버퍼 플러시
  - getStats(): 로깅 통계 조회

- **BagReader**: Bag 파일 읽기
  - open(filepath): 파일 열기
  - seekTime(timestamp): 타임스탬프 기반 탐색
  - next(): 다음 메시지 읽기
  - filter(predicate): 조건부 필터링

- **BagReplayer**: Bag 파일 재생
  - replay(dataStore): DataStore에 복원
  - setSpeedFactor(factor): 속도 조정
  - setTimeRange(start, end): 구간 재생

- **DataStoreBagLogger**: EventBus 구독자로 동작하는 로거
  - 이벤트 구독 및 Bag 파일 쓰기
  - 로깅 전략 설정 및 적용
  - 타입별 직렬화 처리

- **CircularBuffer**: 고정 크기 순환 버퍼
  - push(data): 데이터 추가 (오버플로우 시 가장 오래된 데이터 삭제)
  - getLast(count): 최근 N개 데이터 조회
  - clear(): 버퍼 초기화

- **LoggingStrategy**: 로깅 전략 열거형
  - NONE: 로깅 안 함
  - MEMORY_ONLY: 순환 버퍼 사용
  - EVENT_DRIVEN: 조건부 로깅
  - FULL_BAG: 전체 로깅

## 성공 기준 *(필수)*

### 측정 가능한 결과

- **SC-001**: DataStore 성능 저하가 1% 미만으로 유지됩니다 (벤치마크: 현재 87ns vs 로깅 활성화 88ns 이내)
- **SC-002**: 8시간 운영 시 MissionState와 TaskState의 모든 변경사항(100% 커버리지)이 Bag 파일에 기록됩니다
- **SC-003**: 선택적 로깅 적용 시 디스크 사용량이 전체 로깅 대비 90% 이상 감소합니다 (384MB/hour → 24MB/hour)
- **SC-004**: 1GB 이상의 Bag 파일을 10초 이내에 열고 원하는 시점으로 탐색할 수 있습니다
- **SC-005**: Bag 파일 재생을 통한 회귀 테스트의 재현 정확도가 99% 이상입니다 (타임스탬프 오차 < 1ms)
- **SC-006**: 비동기 쓰기 큐 오버플로우 발생 시에도 시스템 크래시 없이 정상 동작합니다 (드롭 메시지만 기록)
- **SC-007**: 단위 테스트 커버리지가 80% 이상 달성됩니다 (각 Phase별로 최소 10개 이상 테스트)
- **SC-008**: 디스크 공간 부족 시 자동 파일 삭제 및 복구가 5초 이내에 완료됩니다
- **SC-009**: InterfaceData를 MEMORY_ONLY 전략으로 로깅 시 성능 저하가 10% 미만입니다 (87ns → 96ns 이내)

## 가정사항 및 제약사항

### 가정사항

- EventBus와 DataStoreEventAdapter는 이미 구현되어 있으며 정상 동작합니다
- DataStore는 concurrent_hash_map 기반으로 thread-safe합니다
- 파일 시스템은 SSD 기준으로 100μs 이내 쓰기 레이턴시를 제공합니다
- std::any에 저장된 모든 타입은 JSON으로 직렬화 가능합니다

### 제약사항

- InterfaceData 같은 고빈도 데이터(초당 100-1000회)는 전체 로깅 시 성능 저하 위험이 있으므로 MEMORY_ONLY 전략 사용 필수
- JSONL 포맷은 바이너리보다 2-3배 큰 파일 크기를 가질 수 있지만, 디버깅과 호환성을 우선합니다
- 비동기 처리로 인해 이벤트 순서가 완벽히 보장되지 않을 수 있으며, 타임스탬프 기준 정렬이 필요합니다
- Bag 파일 포맷은 확장성을 위해 헤더에 버전 정보를 포함하지만, 하위 호환성은 보장하지 않습니다

## 종속성

- **사전 요구사항**:
  - Phase 019 완료: EventBus 및 DataStoreEventAdapter 정상 동작
  - spdlog: 기존 로깅 프레임워크 (구조화 로그 출력)
  - nlohmann/json: JSON 직렬화 라이브러리

- **외부 의존성**:
  - C++20 표준 라이브러리 (std::any, std::chrono, std::thread)
  - pthread: 비동기 I/O 스레드 관리

- **내부 통합**:
  - DataStore (concurrent_hash_map 기반)
  - EventBus (비동기 이벤트 처리)
  - DataStoreEventAdapter (DataStore ↔ EventBus 연동)
