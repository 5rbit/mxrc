# 기능 사양서: 비동기 로깅 시스템 및 안정성 강화

**기능 브랜치**: `018-async-logging`
**생성일**: 2025-11-19
**상태**: 초안
**입력**: issue/006-spdlog-async-refactor.md
**관련 이슈**: #006 - spdlog 동기 로깅으로 인한 성능 저하

## 사용자 시나리오 및 테스트

### 사용자 스토리 1 - 실시간 제어 루프에서 블로킹 없는 로깅 (우선순위: P1)

로봇 제어 엔지니어는 실시간 제어 루프 내에서 디버깅 정보를 로깅할 때, 파일 I/O 대기로 인한 제어 지연이 발생하지 않아야 합니다.

**이 우선순위인 이유**: 현재 동기식 로깅은 디스크 I/O가 느려질 때 제어 루프 전체를 블로킹하여 로봇의 실시간 응답성을 저해합니다. 이는 안전성과 성능에 치명적인 영향을 미칩니다.

**독립 테스트**: 1000Hz 제어 루프에서 로깅을 수행하며, 로그 출력 유무에 따른 루프 지연 시간을 측정하여 검증 가능합니다.

**인수 시나리오**:

1. **주어진 상황** 1000Hz(1ms 주기) 실시간 제어 루프가 실행 중이고, **언제** 매 루프마다 상태 정보를 로깅할 때, **그러면** 로깅으로 인한 추가 지연이 10μs 미만이어야 합니다.

2. **주어진 상황** 디스크가 일시적으로 느려지는 상황에서, **언제** 로그 버퍼가 가득 찰 때, **그러면** 제어 루프는 블로킹되지 않고 계속 실행되어야 합니다 (로그 손실 허용).

3. **주어진 상황** 고속 데이터 처리 파이프라인에서, **언제** 초당 10,000개 이상의 로그 메시지가 발생할 때, **그러면** 시스템 처리량이 로깅 전 대비 5% 이상 저하되지 않아야 합니다.

---

### 사용자 스토리 2 - 크래시 직전 로그 보존 (우선순위: P1)

시스템 관리자는 로봇 시스템에 예기치 않은 크래시가 발생했을 때, 크래시 직전의 로그를 확인하여 원인을 분석할 수 있어야 합니다.

**이 우선순위인 이유**: 현재 비동기 로깅은 크래시 시 버퍼에 남은 로그가 유실될 위험이 있습니다. 크래시 원인 분석에 가장 중요한 정보가 손실되면 문제 해결이 불가능해집니다.

**독립 테스트**: 의도적으로 세그멘테이션 폴트를 발생시키고, 크래시 직전 로그가 파일에 기록되었는지 확인하여 검증 가능합니다.

**인수 시나리오**:

1. **주어진 상황** 시스템이 정상 동작 중, **언제** SIGSEGV, SIGABRT 등 치명적 시그널로 인해 크래시가 발생할 때, **그러면** 크래시 발생 3초 이내의 모든 로그가 파일에 저장되어야 합니다.

2. **주어진 상황** 로그 레벨이 CRITICAL인 메시지가 기록될 때, **언제** 해당 로그가 큐에 쌓이면, **그러면** 즉시 파일로 플러시되어 유실 위험이 없어야 합니다.

3. **주어진 상황** 시스템이 장시간 실행 중, **언제** 크래시가 발생할 때, **그러면** 백트레이스 정보와 함께 최종 상태가 로그에 기록되어야 합니다.

---

### 사용자 스토리 3 - 중앙화된 로깅 설정 관리 (우선순위: P2)

개발자는 프로젝트 전체에서 일관된 로깅 동작을 유지하고, 로거 설정을 한 곳에서 관리할 수 있어야 합니다.

**이 우선순위인 이유**: 현재 코드베이스에 산재된 개별 로거 생성 코드로 인해 일관성 없는 로그 포맷, 중복된 초기화 로직, 유지보수 어려움이 발생하고 있습니다.

**독립 테스트**: 전체 코드베이스에서 spdlog 로거 생성 코드를 검색하고, 중앙 로거만 사용하는지 확인하여 검증 가능합니다.

**인수 시나리오**:

1. **주어진 상황** 새로운 모듈이 추가될 때, **언제** 로깅이 필요하면, **그러면** 별도의 로거 초기화 없이 중앙 로거를 즉시 사용할 수 있어야 합니다.

2. **주어진 상황** 운영 환경에서 로그 레벨을 변경하고 싶을 때, **언제** 설정 파일을 수정하면, **그러면** 모든 모듈의 로그 레벨이 일괄 변경되어야 합니다.

3. **주어진 상황** 프로덕션 환경에서, **언제** 로그 출력 대상(콘솔/파일)을 변경하고 싶을 때, **그러면** 단일 설정 변경으로 전체 시스템에 적용되어야 합니다.

---

### 엣지 케이스

- 로그 버퍼 오버플로우: 비동기 큐가 가득 찼을 때 어떻게 처리합니까?
  - 기대 동작: block 정책으로 로그 유실 방지, 단 실시간 제어 코드는 타임아웃 설정

- 로거 초기화 전 로깅: main() 이전에 전역 변수 초기화에서 로그를 남기려 하면 어떻게 됩니까?
  - 기대 동작: spdlog 기본 로거가 동기식으로 동작, 초기화 후 비동기로 전환

- 시그널 핸들러 안전성: SIGSEGV 핸들러에서 비동기 로깅을 시도하면 어떻게 됩니까?
  - 기대 동작: spdlog::shutdown()으로 동기식 플러시 수행, 추가 비동기 로깅 시도 안 함

- 다중 프로세스 로깅: fork() 이후 자식 프로세스의 로깅은 어떻게 처리합니까?
  - 기대 동작: 자식 프로세스는 별도 로거 초기화 필요, 부모와 로그 파일 충돌 방지

## 요구사항

### 기능적 요구사항

- **FR-001**: 시스템은 비동기 로깅을 사용하여 로그 호출 시 파일 I/O 대기로 인한 블로킹을 제거해야 합니다.
  - 인수 기준: 로그 호출이 10μs 이내에 반환되고, 백그라운드 스레드가 실제 I/O 처리

- **FR-002**: 시스템은 CRITICAL 레벨 로그를 즉시 플러시하여 크래시 시 유실을 방지해야 합니다.
  - 인수 기준: flush_on(critical) 설정으로 CRITICAL 로그 후 즉시 파일 쓰기

- **FR-003**: 시스템은 주기적으로 로그 버퍼를 플러시하여 장시간 유실 위험을 최소화해야 합니다.
  - 인수 기준: 3초 간격으로 자동 플러시 수행

- **FR-004**: 시스템은 치명적 시그널(SIGSEGV, SIGABRT) 발생 시 백트레이스와 최종 로그를 기록해야 합니다.
  - 인수 기준: 시그널 핸들러에서 spdlog::shutdown() 호출 및 스택 트레이스 로깅

- **FR-005**: 시스템은 중앙화된 로거 초기화 함수를 제공하여 일관된 설정을 보장해야 합니다.
  - 인수 기준: initialize_async_logger() 함수를 main() 시작 시 한 번만 호출

- **FR-006**: 시스템은 로거 자체 오류(파일 쓰기 실패 등)를 처리하여 애플리케이션이 중단되지 않도록 해야 합니다.
  - 인수 기준: set_error_handler로 로거 오류를 stderr로 출력하고 계속 진행

- **FR-007**: 시스템은 기존 spdlog 사용 코드와 호환되어야 합니다.
  - 인수 기준: spdlog::info(), spdlog::error() 등 기존 API 그대로 사용 가능

### 주요 엔티티

- **비동기 로거 (Async Logger)**: 로그 메시지를 큐에 넣고 백그라운드 스레드로 전달하는 로거
  - 속성: 큐 크기(8192), 백그라운드 스레드 수(1), 오버플로우 정책(block)
  - 관계: 애플리케이션당 하나의 기본 로거

- **로그 싱크 (Log Sink)**: 로그 메시지의 실제 출력 대상
  - 속성: 타입(콘솔/파일), 레벨 필터, 포맷 패턴
  - 관계: 하나의 로거가 여러 싱크를 가질 수 있음

- **시그널 핸들러 (Signal Handler)**: 크래시 시 최종 로그를 보존하는 핸들러
  - 속성: 처리할 시그널 목록(SIGSEGV, SIGABRT), 백트레이스 깊이(32)
  - 관계: 로거와 독립적으로 동작하며 spdlog::shutdown() 호출

## 성공 기준

### 측정 가능한 결과

- **SC-001**: 1000Hz 제어 루프에서 로깅 호출 시, 루프 주기가 1.01ms를 초과하지 않아야 합니다 (로깅 오버헤드 1% 이하).
  - 측정 방법: 고해상도 타이머로 루프 주기 측정, 로깅 유무 비교

- **SC-002**: 초당 10,000개의 로그 메시지를 생성할 때, 시스템 전체 처리량이 로깅 전 대비 95% 이상 유지되어야 합니다.
  - 측정 방법: 부하 테스트로 처리량(ops/sec) 측정, 로깅 전후 비교

- **SC-003**: 의도적인 크래시(SIGSEGV) 발생 시, 크래시 3초 이내의 모든 로그가 파일에 저장되어야 합니다.
  - 측정 방법: 테스트 코드로 크래시 유도 후 로그 파일 분석, 타임스탬프 확인

- **SC-004**: CRITICAL 레벨 로그 작성 후, 100ms 이내에 해당 로그가 파일에 기록되어야 합니다.
  - 측정 방법: CRITICAL 로그 직후 파일 수정 시간 확인

- **SC-005**: 프로젝트 전체에서 개별 로거 생성 코드가 제거되고, 중앙 로거만 사용해야 합니다.
  - 측정 방법: 코드 검색으로 spdlog::register_logger, make_shared<spdlog::logger> 사용처 0건

## 비기능적 요구사항

### 성능

- **NFR-001**: 비동기 로깅 호출은 평균 10μs 이내에 완료되어야 합니다.
- **NFR-002**: 백그라운드 로깅 스레드는 CPU 사용률 5% 미만으로 유지해야 합니다.
- **NFR-003**: 로그 큐 버퍼는 최소 8192개 메시지를 저장할 수 있어야 합니다.

### 안정성

- **NFR-004**: 크래시 발생 시 99% 이상의 로그가 파일에 보존되어야 합니다.
- **NFR-005**: 로거 자체 오류로 인한 애플리케이션 중단이 발생하지 않아야 합니다.
- **NFR-006**: 시그널 핸들러는 비동기-시그널-안전 함수만 사용해야 합니다.

### 유지보수성

- **NFR-007**: 로거 설정 변경 시 단일 파일(Log.h) 수정으로 가능해야 합니다.
- **NFR-008**: 기존 spdlog 사용 코드는 API 변경 없이 동작해야 합니다.

## 가정 사항

- spdlog 라이브러리가 프로젝트에 이미 포함되어 있습니다.
- backward-cpp 라이브러리를 백트레이스 생성에 사용할 수 있습니다 (선택적).
- 로그 파일 저장 경로는 쓰기 권한이 있는 디렉토리입니다.
- 시스템은 POSIX 시그널 핸들링을 지원합니다 (Linux/Unix).
- 로그 메시지 평균 크기는 256바이트 이하입니다.

## 범위 외

다음 항목들은 이번 개선 범위에 포함되지 않습니다:

- 로그 로테이션 및 압축 (OS 레벨 도구 사용)
- 원격 로그 수집 시스템 연동 (syslog, Elasticsearch 등)
- 로그 프로세스 분리 (IPC 기반, 장기 과제)
- 구조화된 로깅 (JSON 포맷 등)

## 기술적 제약사항

- 실시간 제어 코드에서 로깅 블로킹 최소화
- 크래시 시 로그 유실 최소화
- 기존 코드와의 호환성 유지
