# Action, Sequence, Task 통합 관리 시스템

## 개요

이 시스템은 로봇 제어를 위한 세 가지 계층(Action, Sequence, Task)을 구현합니다.
Action은 로봇 동작의 기본 정의 함수이며, Sequence는 여러 Action의 순차적 조합이고,
Task는 단일 Action 또는 Sequence를 포함하는 작업 관리 단위입니다.

**구현 순서**: Action → Sequence → Task (단계적 구현 및 테스트)
**Mission**: Task 완료 후 별도 구현 예정

이 시스템은 동작들 간의 의존성을 관리하고, 조건부 분기를 지원하며, 재시도 및 에러 처리를 포함하여
확장 가능하고 유지보수하기 쉬운 구조를 제공합니다.

## 사용자 시나리오

### 시나리오 1: 기본 순차 동작 (Sequential Actions)
**배경**: 로봇이 상자를 집어 들었다가 목표 지점에 놓아야 합니다.  
**흐름**:
1. 사용자가 "물건 이동" 시퀀스를 정의 (이동 → 집기 → 돌리기 → 놓기)
2. 시스템이 각 동작을 순차적으로 실행
3. 각 동작 완료 후 다음 동작 시작
4. 모든 동작 완료 시 시퀀스 종료

**기대 결과**: 시퀀스가 정의된 순서대로 모든 동작을 완료하고 최종 상태 보고

---

### 시나리오 2: 조건부 분기 (Conditional Branches)
**배경**: 로봇이 객체의 무게에 따라 다른 동작을 수행해야 합니다.  
**흐름**:
1. "무게 감지 및 처리" 시퀀스 정의
2. 무게 감지 동작 실행
3. 결과에 따라 분기:
   - 무거우면: 양손으로 집기 경로
   - 가벼우면: 한 손으로 집기 경로
4. 해당 경로의 동작들 실행

**기대 결과**: 조건에 따라 올바른 동작 경로가 선택되어 실행됨

---

### 시나리오 3: 병렬 동작 (Parallel Actions)
**배경**: 로봇의 여러 팔이 독립적으로 작동할 수 있습니다.  
**흐름**:
1. "양팔 협력 작업" 시퀀스 정의
2. 왼쪽 팔 동작 그룹과 오른쪽 팔 동작 그룹을 동시에 실행
3. 모든 동작 완료 대기
4. 다음 시퀀스 단계 진행

**기대 결과**: 병렬 동작들이 동시에 안전하게 실행되고 모두 완료됨

---

### 시나리오 4: 재시도와 에러 처리 (Retry & Error Handling)
**배경**: 네트워크 불안정성으로 동작이 실패할 수 있습니다.  
**흐름**:
1. "통신 재시도" 시퀀스 정의 (최대 3회 재시도)
2. 동작 실행
3. 실패 시:
   - 자동 재시도 (지수 백오프)
   - 3회 재시도 후에도 실패 시 에러 처리 경로로 진입
4. 에러 핸들러가 복구 동작 수행

**기대 결과**: 일시적 오류는 자동으로 복구되고, 영구적 오류는 안전하게 처리됨

---

### 시나리오 5: 시퀀스 템플릿과 재사용 (Reusable Templates)
**배경**: 여러 작업에서 공통 패턴을 반복 사용합니다.  
**흐름**:
1. "픽앤플레이스" 템플릿 정의 (집기 + 이동 + 놓기)
2. 서로 다른 좌표와 속도로 여러 번 인스턴스화
3. 각 인스턴스가 독립적으로 실행
4. 결과 집계

**기대 결과**: 템플릿으로 정의된 시퀀스를 다양한 파라미터로 재사용 가능

---

### 시나리오 6: 시퀀스 모니터링과 제어 (Monitoring & Control)
**배경**: 시퀀스 실행 중 상태를 확인하고 필요시 중단해야 합니다.
**흐름**:
1. 장시간 실행되는 시퀀스 시작
2. 실시간으로 진행 상황 모니터링:
   - 현재 실행 중인 동작
   - 완료된 동작 목록
   - 진행률
3. 필요시 일시정지 또는 취소
4. 일시정지 후 재개 또는 마지막 안전한 지점에서 중단

**기대 결과**: 시퀀스 실행 상태를 실시간으로 추적하고 제어 가능

---

### 시나리오 7: Task 주기적 실행 (Periodic Task Execution)
**배경**: 센서 데이터를 주기적으로 읽어 처리해야 합니다.
**흐름**:
1. "센서 읽기" Task를 100ms 주기로 설정
2. Task가 주기적으로 실행되며 센서 값 확인
3. 이상 값 감지 시 경고 Action 실행
4. 조건 충족 시 Task 중단

**기대 결과**: Task가 설정된 주기로 반복 실행되며, 조건에 따라 중단 가능

---

### 시나리오 8: Task 트리거 실행 (Triggered Task Execution)
**배경**: 특정 이벤트 발생 시 Task를 실행해야 합니다.
**흐름**:
1. "비상 정지" Task를 이벤트 트리거로 설정
2. 비상 버튼 이벤트 발생
3. Task가 즉시 실행되어 모든 모터 정지
4. 안전 상태 확인 후 Task 완료

**기대 결과**: 이벤트 발생 시 Task가 즉시 실행되고 안전하게 처리됨

---

## 함수 요구사항

### FR1: 시퀀스 정의 및 등록
- **FR1.1**: 시퀀스를 이름, 버전, 설명으로 정의 가능
- **FR1.2**: 시퀀스에 동작(Action)들을 순서대로 추가 가능
- **FR1.3**: 시퀀스를 시스템에 등록하여 재사용 가능
- **FR1.4**: 등록된 시퀀스 목록 조회 가능

### FR2: 동작(Action) 관리
- **FR2.1**: 기본 동작 타입 지원 (이동, 집기, 놓기 등)
- **FR2.2**: 각 동작에 파라미터 설정 가능 (좌표, 속도, 힘 등)
- **FR2.3**: 동작에 타임아웃 설정 가능
- **FR2.4**: 동작 사이 대기 시간(Delay) 설정 가능

### FR3: 조건부 분기 (Conditional Flow Control)
- **FR3.1**: IF-THEN-ELSE 조건문 지원
- **FR3.2**: 조건식에서 이전 동작의 결과 참조 가능
- **FR3.3**: 비교 연산자 지원 (==, !=, <, >, <=, >=)
- **FR3.4**: 논리 연산자 지원 (AND, OR, NOT)

### FR4: 병렬 실행 (Parallel Execution)
- **FR4.1**: 여러 동작을 병렬로 실행 가능
- **FR4.2**: 병렬 그룹이 모두 완료될 때까지 대기 (Join)
- **FR4.3**: 병렬 그룹 내 동작들의 상호 간섭 최소화
- **FR4.4**: 병렬 그룹의 시간초과 설정 가능

### FR5: 재시도 및 에러 처리
- **FR5.1**: 동작 실패 시 자동 재시도 설정 가능
- **FR5.2**: 재시도 간격을 지수 백오프로 증가 가능
- **FR5.3**: 최대 재시도 횟수 설정 가능
- **FR5.4**: 재시도 실패 시 에러 핸들러 실행
- **FR5.5**: 에러 핸들러가 복구 동작 실행 또는 시퀀스 중단 결정

### FR6: 시퀀스 실행 제어
- **FR6.1**: 시퀀스 실행 시작 가능
- **FR6.2**: 실행 중인 시퀀스 일시정지 가능
- **FR6.3**: 일시정지된 시퀀스 재개 가능
- **FR6.4**: 시퀀스 취소 가능 (현재 동작 중단 + 정리)
- **FR6.5**: 시퀀스 재시작 가능 (처음부터 다시 시작)

### FR7: 실시간 모니터링
- **FR7.1**: 현재 실행 중인 동작 조회 가능
- **FR7.2**: 완료된 동작 목록 조회 가능
- **FR7.3**: 시퀀스 전체 진행률(%) 계산 가능
- **FR7.4**: 각 동작의 상태 조회 가능 (PENDING, RUNNING, COMPLETED, FAILED)
- **FR7.5**: 시퀀스 실행 로그 기록

### FR8: 상태 저장 및 복구
- **FR8.1**: 시퀀스 실행 상태 저장 가능
- **FR8.2**: 저장된 상태에서 복구 가능
- **FR8.3**: 중단 지점부터 재개 가능

### FR9: 확장성
- **FR9.1**: 새로운 동작 타입 추가 가능 (플러그인 방식)
- **FR9.2**: 커스텀 조건 함수 등록 가능
- **FR9.3**: 커스텀 에러 핸들러 등록 가능

### FR10: 성능 및 안정성
- **FR10.1**: 1000개 이상 동작을 가진 시퀀스 처리 가능
- **FR10.2**: 시퀀스 내 메모리 누수 없음 (RAII 원칙 준수)
- **FR10.3**: 동작 실패 시 시스템 안정성 유지
- **FR10.4**: 멀티스레드 환경에서 스레드 안전성 보장

### FR11: Task 관리
- **FR11.1**: Task는 단일 Action 또는 Sequence를 포함 가능
- **FR11.2**: Task 실행 모드 지원: 단일 실행, 주기적 실행, 트리거 실행
- **FR11.3**: 주기적 실행 시 interval 파라미터로 주기 설정 가능
- **FR11.4**: 트리거 실행 시 이벤트 기반 실행 가능
- **FR11.5**: Task 상태 관리 (PENDING, RUNNING, PAUSED, COMPLETED, FAILED, CANCELLED)
- **FR11.6**: Task 실행 중 일시정지, 재개, 취소 가능
- **FR11.7**: TaskManager에 의한 Task 생명주기 관리
- **FR11.8**: Task 간 우선순위 설정 가능

### FR12: Action 정의
- **FR12.1**: Action은 로봇 동작의 기본 단위
- **FR12.2**: Action 타입 확장 가능 (플러그인 방식)
- **FR12.3**: Action 실행 결과 반환 (성공/실패, 데이터)
- **FR12.4**: Action 타임아웃 설정 가능
- **FR12.5**: Action 취소 기능 지원

---

## 성공 기준

1. **기능 완성도**:
   - Action → Sequence → Task 순서로 단계적 구현 및 테스트 완료
   - 모든 FR 12개 카테고리가 구현되고 테스트됨
2. **성능**:
   - 1000개 동작 시퀀스가 메모리 오버헤드 <100MB로 처리됨
   - Task 주기적 실행 오버헤드 < 1ms
3. **신뢰성**:
   - Action/Sequence/Task 실행 중 메모리 누수 없음
   - 에러 발생 시에도 시스템 안정성 유지
   - 90% 이상의 재시도 성공률
4. **유지보수성**:
   - 새로운 Action 타입 추가 시간 < 30분
   - 코드 복잡도 (Cyclomatic) < 10
   - 각 계층(Action/Sequence/Task) 독립적 테스트 가능
5. **확장성**:
   - 플러그인 시스템을 통해 Action 타입 확장 가능
   - Task 실행 모드 확장 가능
6. **모니터링**:
   - 모든 Action/Sequence/Task 실행이 추적 가능하고 로깅됨
   - Task 상태 실시간 조회 가능

---

## 주요 엔티티

### SequenceDefinition (시퀀스 정의)
- `id`: 시퀀스 식별자
- `name`: 시퀀스 이름
- `version`: 버전
- `description`: 설명
- `actions`: 포함된 동작 리스트
- `createdAt`: 생성 시간
- `updatedAt`: 수정 시간

### Action (동작)
- `id`: 동작 식별자
- `type`: 동작 유형 (Move, Grip, Release 등)
- `parameters`: 파라미터 맵
- `timeout`: 타임아웃 (밀리초)
- `delay`: 실행 전 대기 시간 (밀리초)
- `retryPolicy`: 재시도 정책

### SequenceExecution (시퀀스 실행)
- `id`: 실행 식별자
- `sequenceId`: 참조 시퀀스 ID
- `status`: 상태 (PENDING, RUNNING, PAUSED, COMPLETED, FAILED, CANCELLED)
- `progress`: 진행률 (0-100)
- `currentActionIndex`: 현재 실행 중인 동작 인덱스
- `actionResults`: 각 동작의 실행 결과 맵
- `startTime`: 시작 시간
- `endTime`: 종료 시간

### ExecutionLog (실행 로그)
- `executionId`: 실행 ID
- `actionId`: 동작 ID
- `status`: 동작 상태
- `result`: 실행 결과
- `errorMessage`: 에러 메시지 (발생 시)
- `timestamp`: 기록 시간

### TaskDefinition (Task 정의)
- `id`: Task 식별자
- `name`: Task 이름
- `type`: Task 타입 (SINGLE_ACTION, SEQUENCE_BASED)
- `actionId`: 단일 Action ID (type이 SINGLE_ACTION인 경우)
- `sequenceId`: Sequence ID (type이 SEQUENCE_BASED인 경우)
- `executionMode`: 실행 모드 (ONCE, PERIODIC, TRIGGERED)
- `interval`: 주기 (밀리초, PERIODIC 모드 시)
- `triggerCondition`: 트리거 조건 (TRIGGERED 모드 시)
- `priority`: 우선순위 (0-100)
- `parameters`: 파라미터 맵

### TaskExecution (Task 실행)
- `id`: 실행 식별자
- `taskId`: 참조 Task ID
- `status`: 상태 (PENDING, RUNNING, PAUSED, COMPLETED, FAILED, CANCELLED)
- `progress`: 진행률 (0-100)
- `executionCount`: 실행 횟수 (주기적 실행 시)
- `lastExecutionTime`: 마지막 실행 시간
- `nextExecutionTime`: 다음 실행 시간 (주기적 실행 시)
- `startTime`: 시작 시간
- `endTime`: 종료 시간

---

## 가정사항

1. **구현 순서**: Action → Sequence → Task 순서로 단계적 구현
2. **독립 테스트**: 각 계층은 독립적으로 테스트 가능해야 함
3. **Action**: 가장 기본적인 로봇 동작 정의 단위
4. **Sequence**: 여러 Action의 순차/조건부/병렬 조합
5. **Task**: 단일 Action 또는 Sequence를 포함하며, TaskManager가 관리
6. **Mission**: Task 완료 후 별도 구현 (이 사양에 포함되지 않음)
7. 동작들 간의 명시적 의존성만 지원 (암묵적 의존성 X)
8. 조건 평가는 동기식으로 수행 (비동기 조건 평가 X)
9. 병렬 동작 간 리소스 충돌은 개별 동작에서 처리
10. 시퀀스 정의는 정적이며, 실행 중 변경 불가능
11. 재시도는 실패한 개별 Action에만 적용
12. 타임아웃은 각 Action별로 적용
13. Task 주기적 실행은 별도 스레드에서 관리
14. 로그는 메모리 기반이며, 별도 영속성 계층과 통합 필요

---

## 제약사항

- 최대 시퀀스 깊이(nesting): 10단계
- 최대 병렬 그룹 크기: 32개 동작
- 최대 조건 복잡도: 5개 변수까지 조합 가능

---

## 시나리오 7: 로깅 및 추적 (Logging & Tracing) - Phase 4

**배경**: 개발자가 복잡한 시퀀스의 실행 흐름을 디버깅하고 추적해야 합니다.
**흐름**:
1. 복잡한 시퀀스 (10+ Action, 조건부 분기 포함) 실행
2. 각 계층(Action, Sequence, Task)에서 상세한 로그 생성:
   - Action: 실행 시작/종료 시간, 파라미터, 결과
   - Sequence: 스텝 번호, 조건 평가 결과, 분기 선택
   - Task: 상태 전환, 실행 모드, 진행률
3. 구조화된 로그 포맷으로 타임스탬프, 레벨, 컨텍스트 포함
4. 실행 추적 시각화 헬퍼로 전체 흐름 확인

**기대 결과**:
- 전체 실행 흐름을 추적 가능
- 에러 발생 시 정확한 위치와 원인 파악 가능
- 계층별 실행 시간 메트릭 수집

**Phase 4 추가 요구사항**:
- **FR-11**: 모든 Action 실행에 대해 시작/종료 로그 및 실행 시간 기록
- **FR-12**: Sequence 스텝별 진행 상황 및 조건 평가 결과 로그
- **FR-13**: Task 상태 전환 시 이전/현재 상태 및 전환 이유 로그
- **FR-14**: TaskRegistry 등록/제거 작업에 대한 로그 추적
- **FR-15**: 디버그 모드에서 상세 로깅 활성화 기능
- **FR-16**: 에러 발생 시 전체 실행 컨텍스트(호출 스택, 변수 상태) 로그

