# 연구 결과: DataStore 동시성 메커니즘

**날짜**: 2025-11-16
**기능**: DataStore 동시성 리팩토링

## 결정: 동시성 해시 맵 사용

### Rationale (근거)

`DataStore`의 내부 저장소에 **동시성 해시 맵(Concurrent Hash Map)**을 사용하는 것으로 결정했습니다. 이 접근 방식은 다음과 같은 이유로 현재의 전역 락(Global Lock)으로 인한 성능 병목 현상을 해결하는 데 가장 적합합니다.

1.  **고성능 및 확장성**: 동시성 해시 맵은 내부적으로 세분화된 락(Fine-Grained Locking) 또는 락-프리(Lock-Free) 알고리즘을 사용하여 높은 수준의 병렬 처리와 처리량(Throughput)을 제공합니다. 이는 여러 스레드가 동시에 `DataStore`에 접근할 때 블로킹을 최소화하여 시스템의 응답성과 확장성을 크게 향상시킬 것입니다.
2.  **스레드 안전성**: 검증된 동시성 자료구조는 복잡한 동시성 문제를 내부적으로 안전하게 처리합니다. 이는 수동으로 락을 관리할 때 발생할 수 있는 데드락, 레이스 컨디션, 데이터 손상과 같은 미묘한 버그의 위험을 줄여줍니다.
3.  **구현 복잡성 감소**: 직접 키별 락(Per-Key Locking)을 구현하는 것보다 검증된 동시성 해시 맵을 사용하는 것이 개발 및 유지보수 측면에서 더 간단하고 효율적입니다. 이는 개발 시간을 단축하고 코드 품질을 높이는 데 기여합니다.
4.  **기존 인터페이스 유지**: `DataStore`의 외부 인터페이스(`get`, `set`, `delete`)는 변경되지 않으므로, 기존 코드를 수정할 필요 없이 내부 구현만 교체하여 투명하게 성능을 개선할 수 있습니다.

### Alternatives Considered (고려된 대안)

1.  **키별 락(Per-Key Locking)**:
    *   **설명**: `DataStore` 내부에 각 키에 대한 뮤텍스를 관리하는 맵(`std::map<std::string, std::mutex>`)을 두어, `set` 또는 `get` 연산 시 해당 키에 해당하는 뮤텍스만 잠그는 방식입니다.
    *   **장점**: 서로 다른 키에 대한 접근은 완전히 병렬로 처리될 수 있습니다. 외부 라이브러리 의존성이 없습니다.
    *   **단점**:
        *   **구현 복잡성**: 뮤텍스의 생성, 소멸, 조회 및 관리 로직이 복잡하며, 정확한 구현이 어렵습니다. 특히 키가 동적으로 생성되고 삭제될 때 뮤텍스 맵의 일관성을 유지하는 것이 까다롭습니다.
        *   **오버헤드**: 뮤텍스 맵 자체의 관리 오버헤드와 각 키 접근 시 뮤텍스 조회 오버헤드가 발생할 수 있습니다.
        *   **버그 위험**: 수동 락 관리의 특성상 데드락이나 레이스 컨디션과 같은 동시성 버그가 발생할 위험이 높습니다.

### 결론

키별 락 방식의 복잡성과 잠재적 위험을 고려할 때, 검증된 **동시성 해시 맵**을 사용하는 것이 `DataStore`의 성능 병목 현상을 안전하고 효율적으로 해결하는 최적의 방법이라고 판단했습니다. 프로젝트의 기술 스택(C++20)과 성능 요구사항을 고려할 때, Intel TBB의 `concurrent_hash_map`과 같은 고품질 라이브러리를 활용하는 것을 우선적으로 검토할 것입니다. 만약 외부 라이브러리 도입에 제약이 있다면, 동시성 해시 맵의 원리를 기반으로 한 간소화된 커스텀 구현을 고려할 수 있습니다.
