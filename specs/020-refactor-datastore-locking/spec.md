# 기능 사양서: DataStore 동시성 리팩토링

**기능 브랜치**: `020-refactor-datastore-locking`
**생성일**: 2025-11-16
**상태**: 초안
**입력**: 사용자 설명: "/issue/002-* 를 참고로 해서 /specs/020-*.md 를 만들고 새로운 브랜치에서 사양을 작성하고 작업을 할 수 있도록 준비해"

## 사용자 시나리오 및 테스트 *(필수)*

### 사용자 스토리 1 - 동시 쓰기 상황에서 시스템 안정성 확보 (우선순위: P1)

여러 시스템 모듈(예: 이벤트 핸들러, 태스크)이 동시에 `DataStore`에 데이터를 쓸 때, 시스템은 블로킹 없이 안정적으로 작업을 처리해야 합니다. 이는 시스템 전체의 응답성과 처리량을 보장하기 위함입니다.

**이 우선순위인 이유**: 현재의 전역 락(Global Lock)은 시스템 전체를 멈추게 할 수 있는 심각한 병목 현상을 유발하며, 이는 치명적인 안정성 문제입니다. 이 문제를 해결하는 것이 최우선 과제입니다.

**독립 테스트**: `DataStoreEventAdapter`의 동시성 테스트(`ConcurrentEventBusPublish`, `ConcurrentDataStoreUpdates`)를 실행하여 타임아웃 없이 일관되게 통과하는지 확인함으로써 독립적으로 테스트할 수 있습니다.

**인수 시나리오**:

1.  **주어진 상황** 10개의 스레드가 동시에 `DataStore`에 **서로 다른** 키(key)로 값을 쓰려고 할 때, **언제** 모든 쓰기 작업이 시작되면, **그러면** 시스템은 데드락이나 타임아웃 없이 모든 쓰기 작업을 지정된 시간(성공 기준 참조) 내에 완료해야 합니다.
2.  **주어진 상황** `EventBus`에 `DataStore`에 데이터를 쓰는 수백 개의 이벤트가 한꺼번에 발행될 때, **언제** 이벤트 처리가 시작되면, **그러면** `EventBus`는 다른 이벤트를 처리하는 데 있어 심각한 지연 없이 모든 이벤트를 처리해야 합니다.

---

### 엣지 케이스

- 여러 스레드가 동시에 **동일한** 키에 쓰려고 할 때 어떻게 됩니까? (데이터 무결성은 보장되어야 하며, 마지막 쓰기가 최종 값이 되어야 합니다.)
- 쓰기 작업이 매우 많은 상황에서 시스템 메모리 사용량은 어떻게 됩니까?

## 요구사항 *(필수)*

### 기능적 요구사항

- **FR-001**: `DataStore`는 여러 스레드가 **서로 다른** 키에 동시에 쓰는 작업을 허용해야 하며, 이 과정에서 스레드 간 블로킹이 발생해서는 안 됩니다.
- **FR-002**: `DataStore`는 여러 스레드가 **동일한** 키에 동시에 쓰는 작업을 시도할 때 데이터의 무결성을 보장해야 합니다.
- **FR-003**: `DataStore`에 대한 단일 쓰기 작업이 시스템의 다른 부분(특히 `EventBus`의 이벤트 처리 루프)을 장시간 블로킹해서는 안 됩니다.
- **FR-004**: 리팩토링된 `DataStore`는 기존의 `get`, `set`, `delete` 인터페이스를 그대로 유지해야 합니다.

### 주요 엔티티 *(기능에 데이터가 포함된 경우 포함)*

- **DataStore**: 시스템 전반의 데이터를 키-값 형태로 저장하는 중앙 저장소입니다. 키는 문자열이며, 값은 다양한 데이터 타입을 가질 수 있습니다.

## 성공 기준 *(필수)*

### 측정 가능한 결과

- **SC-001**: `DataStoreEventAdapter_test.cpp`의 `ConcurrentEventBusPublish` 및 `ConcurrentDataStoreUpdates` 테스트가 100%의 성공률로, 타임아웃 없이 통과해야 합니다.
- **SC-002**: 10개의 동시 스레드가 각각 100개의 고유 키에 쓰는 스트레스 테스트(총 1,000회 쓰기)가 500ms 이내에 완료되어야 합니다.
- **SC-003**: `EventBus` 디스패치 루프는 단일 `DataStore` 쓰기 작업으로 인해 10ms 이상 블로킹되어서는 안 됩니다.
- **SC-004**: 리팩토링 이후, `DataStore` 관련 기능의 CPU 및 메모리 사용량이 기존 대비 20% 이상 증가해서는 안 됩니다.
