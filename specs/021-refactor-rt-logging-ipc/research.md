# Research: RT/Non-RT 아키텍처 개선

**Date**: 2025-11-21
**Status**: Completed
**Relevant Plan**: [plan.md](plan.md)

## 1. Lock-Free 큐: 라이브러리 사용 vs. 자체 구현

### 결정
- **Boost.Lockfree 라이브러리 (`boost::lockfree::spsc_queue`)를 사용한다.**

### 근거
- **정확성 및 안정성**: Lock-free 자료구조를 처음부터 올바르게 구현하는 것은 매우 복잡하며, 미묘한 동시성 버그를 유발할 가능성이 높습니다. `Boost`는 광범위하게 사용되고 검증된 라이브러리로, 구현의 정확성을 보장합니다.
- **개발 시간 단축**: 이미 검증된 솔루션을 사용함으로써, 복잡한 자료구조 구현 및 테스트에 소요되는 시간을 절약하고 핵심 비즈니스 로직에 집중할 수 있습니다.
- **유지보수**: 자체 구현 코드보다 잘 문서화된 표준 라이브러리를 사용하는 것이 장기적인 유지보수에 유리합니다.
- **SPSC (Single-Producer, Single-Consumer) 최적화**: 우리의 사용 사례(RT 프로세스가 생산자, Non-RT 프로세스가 소비자)는 단일 생산자/소비자 모델에 정확히 부합합니다. `boost::lockfree::spsc_queue`는 이러한 시나리오에 최적화되어 있어 매우 높은 성능을 제공합니다.

### 고려된 대안
- **자체 구현**: 가장 높은 수준의 커스터마이징이 가능하지만, 구현 및 검증의 복잡성과 위험 부담이 너무 큽니다.
- **TBB `concurrent_queue`**: 프로젝트에 이미 `TBB`가 사용되고 있어 의존성 추가 부담이 없지만, `concurrent_queue`는 다중 생산자/소비자(MPMC)를 위한 범용 큐이므로 SPSC에 최적화된 큐보다 오버헤드가 발생할 수 있으며, 엄격한 Lock-Free를 보장하지 않을 수 있습니다.

---

## 2. 실시간-안전 공유 메모리 링 버퍼 설계

### 결정
- **`mmap`으로 파일을 공유하는 방식의 링 버퍼를 사용하며, 헤더에 `std::atomic`으로 원자화된 `head`와 `tail` 인덱스를 둔다.**

### 상세 설계
1.  **메모리 생성**:
    - Non-RT 프로세스가 시작 시 `ftruncate`를 사용하여 고정된 크기(예: 16MB)의 파일을 생성합니다.
    - 이 파일을 `shm_open`과 `mmap`을 사용하여 두 프로세스의 가상 주소 공간에 `MAP_SHARED` 플래그로 매핑합니다.

2.  **버퍼 구조**:
    - 공유 메모리 영역의 시작 부분에 헤더를 둡니다.
    - 헤더 포함 내용:
        - `std::atomic<size_t> head`: 다음에 쓸 위치를 가리키는 인덱스. 생산자(RT)만 이 값을 수정합니다.
        - `std::atomic<size_t> tail`: 다음에 읽을 위치를 가리키는 인덱스. 소비자(Non-RT)만 이 값을 수정합니다.
        - `std::atomic<size_t> dropped_count`: 버퍼 오버플로우로 인해 유실된 로그의 수.

3.  **동작 방식**:
    - **생산자 (RT 프로세스)**:
        - 로그 메시지를 버퍼의 `head` 위치에 씁니다.
        - `head` 인덱스를 원자적으로 증가시킵니다 (`fetch_add`).
        - 만약 `head`가 `tail`을 따라잡으면 (버퍼가 꽉 참), `dropped_count`를 증가시키고 가장 오래된 데이터를 덮어씁니다. 이 방식은 생산자가 절대 블록되지 않도록 보장합니다.
    - **소비자 (Non-RT 프로세스)**:
        - 주기적으로 `head`와 `tail` 인덱스를 확인하여 읽을 데이터가 있는지 검사합니다.
        - `tail` 위치에서 데이터를 읽어 `spdlog`를 통해 파일에 기록합니다.
        - `tail` 인덱스를 원자적으로 증가시킵니다.
        - `dropped_count`가 0보다 크면, 유실된 로그가 있다는 경고 로그를 남깁니다.

### 고려된 대안
- **System V 공유 메모리 (`shmget`)**: 구형 방식이며, 키 관리와 `ipcs` 명령을 통한 정리 등 관리가 더 번거롭습니다. 파일 시스템에 매핑되는 `mmap` 방식이 더 현대적이고 직관적입니다.
