#include "TaskManager.h"
#include "TaskDefinitionRegistry.h"
#include "TaskExecutor.h"
#include "commands/StartTaskCommand.h"
#include "commands/CancelTaskCommand.h"
#include "commands/PauseTaskCommand.h"
#include "interfaces/ITask.h" 
#include <iostream>
#include <typeinfo> 
#include <algorithm>

namespace mxrc {
namespace core {
namespace taskmanager {

TaskManager::TaskManager(std::shared_ptr<TaskDefinitionRegistry> registry, std::shared_ptr<TaskExecutor> executor)
    : registry_(registry), executor_(executor) {
    if (!registry_ || !executor_) {
        throw std::runtime_error("TaskManager initialized with null registry or executor.");
    }
}

std::string TaskManager::registerTaskDefinition(const std::string& taskName, const std::string& taskType, const std::map<std::string, std::string>& defaultParameters) {
    // Generate a unique ID for the task definition
    std::string taskId = "task_" + std::to_string(tasks_.size() + 1); // Simple ID generation

    // Check for duplicate task name
    auto it = std::find_if(tasks_.begin(), tasks_.end(),
                           [&](const TaskDto& dto) { return dto.name == taskName; });
    if (it != tasks_.end()) {
        throw std::runtime_error("Task with name '" + taskName + "' already exists.");
    }

    // Store the task definition
    tasks_.emplace_back(taskId, taskName, taskType, TaskStatus::PENDING, 0.0f, defaultParameters);
    return taskId;
}

std::vector<TaskDto> TaskManager::getAllTaskDefinitions() const {
    return tasks_;
}

std::unique_ptr<TaskDto> TaskManager::getTaskDefinitionById(const std::string& taskId) const {
    auto it = std::find_if(tasks_.begin(), tasks_.end(),
                           [&](const TaskDto& dto) { return dto.id == taskId; });
    if (it != tasks_.end()) {
        return std::make_unique<TaskDto>(*it);
    }
    return nullptr;
}

std::string TaskManager::requestTaskExecution(const std::string& taskId, const std::map<std::string, std::string>& runtimeParameters) {
    // Find the task definition
    std::unique_ptr<TaskDto> taskDto = getTaskDefinitionById(taskId);
    if (!taskDto) {
        throw std::runtime_error("Task definition not found for ID: " + taskId);
    }

    // Create a StartTaskCommand and execute it
    auto startCommand = std::make_shared<StartTaskCommand>(*this, taskId, runtimeParameters);
    executeCommand(startCommand);

    // For simplicity, return the taskId as the executionId.
    // In a real system, a unique executionId would be generated by the TaskExecutor.
    return taskId;
}

std::unique_ptr<TaskDto> TaskManager::getTaskExecutionStatus(const std::string& executionId) const {
    // Retrieve the actual task from the executor
    std::shared_ptr<ITask> task = executor_->getTask(executionId);
    if (task) {
        return std::make_unique<TaskDto>(task->toDto());
    }
    // If not found in executor, check if it's a defined task (not yet executed or completed)
    return getTaskDefinitionById(executionId);
}

void TaskManager::executeCommand(std::shared_ptr<ICommand> command) {
    if (!command) {
        std::cerr << "Error: Attempted to execute a null command." << std::endl;
        return;
    }

    // The commands themselves now contain the logic to interact with TaskExecutor
    command->execute();
}

} // namespace taskmanager
} // namespace core
} // namespace mxrc